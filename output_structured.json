[
  {
    "source": "JavaLesBases.pdf",
    "page": 1,
    "type": "paragraph",
    "text": "Les bases de la programmation orientée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 1,
    "type": "paragraph",
    "text": "objet avec Java"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 1,
    "type": "paragraph",
    "text": "Etienne Duris"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 2,
    "type": "paragraph",
    "text": "Etienne DURIS © ESIPE­MLV Université Paris­Est Marne­la­Vallée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 2,
    "type": "paragraph",
    "text": "2"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 2,
    "type": "paragraph",
    "text": "Bibliographie et sources"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 2,
    "type": "paragraph",
    "text": "➢ Les cours de Rémi Forax"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 2,
    "type": "paragraph",
    "text": "http://igm.univ­mlv.fr/~forax/"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 2,
    "type": "paragraph",
    "text": "➢ Le cours de Marie­Pierre Béal"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 2,
    "type": "paragraph",
    "text": "http://igm.univ­mlv.fr/~beal/"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 2,
    "type": "paragraph",
    "text": "➢ Java et Internet"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 2,
    "type": "paragraph",
    "text": "G. Roussel, E. Duris, N. Bedon et R. Forax. Vuibert 2002."
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 2,
    "type": "paragraph",
    "text": "➢ Documentations Java Oracle"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 2,
    "type": "paragraph",
    "text": "http://docs.oracle.com/javase/"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 2,
    "type": "section",
    "text": "➢ The Java Language Specification, Third Edition:"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 2,
    "type": "paragraph",
    "text": "http://java.sun.com/docs/books/jls/"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 2,
    "type": "section",
    "text": "➢ The Java Virtual Machine Specification, Second Ed:"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 2,
    "type": "paragraph",
    "text": "http://java.sun.docs/books/jvms"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 3,
    "type": "paragraph",
    "text": "Etienne DURIS © ESIPE­MLV Université Paris­Est Marne­la­Vallée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 3,
    "type": "paragraph",
    "text": "3"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 3,
    "type": "paragraph",
    "text": "Il existe différents styles de programmation"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 3,
    "type": "paragraph",
    "text": "➢ Style applicatif"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 3,
    "type": "paragraph",
    "text": "➢ Fondé sur l'évaluation d'expressions qui ne dépendent que de la"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 3,
    "type": "paragraph",
    "text": "valeur des arguments, et non de l'état de la mémoire"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 3,
    "type": "paragraph",
    "text": "➢ On parle aussi de programmation fonctionnelle"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 3,
    "type": "paragraph",
    "text": "➢ Proche des notations mathématiques, utilise beaucoup la récursivité"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 3,
    "type": "paragraph",
    "text": "➢ Accepte des arguments, produit un résultat (pas d'« effet de bord »)"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 3,
    "type": "diagram_element",
    "text": "➢ Ex: Lisp, Caml, ML, Haskel"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 3,
    "type": "paragraph",
    "text": "➢ Style impératif"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 3,
    "type": "paragraph",
    "text": "➢ Fondé sur l'exécution d'instructions qui modifient l'état de la"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 3,
    "type": "paragraph",
    "text": "mémoire"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 3,
    "type": "paragraph",
    "text": "➢ Utilise beaucoup les itérations et autres structures de contrôle"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 3,
    "type": "paragraph",
    "text": "➢ Les structures de données sont fondamentales"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 3,
    "type": "diagram_element",
    "text": "➢ Ex: Fortran, C, Pascal"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 4,
    "type": "paragraph",
    "text": "Etienne DURIS © ESIPE­MLV Université Paris­Est Marne­la­Vallée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 4,
    "type": "paragraph",
    "text": "4"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 4,
    "type": "paragraph",
    "text": "Le style objet"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 4,
    "type": "paragraph",
    "text": "➢ C'est un style de programmation où l'on considère que des"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 4,
    "type": "code_line",
    "text": "composants autonomes (les objets ) disposent de ressources et de moyens d'interactions entre­eux."
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 4,
    "type": "paragraph",
    "text": "➢ Ces objets représentent des données qui sont modélisées par"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 4,
    "type": "paragraph",
    "text": "des classes qui définissent des types"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 4,
    "type": "paragraph",
    "text": "➢ un peu comme typedef struct en C"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 4,
    "type": "paragraph",
    "text": "➢ En plus de la manière dont sont structurés leurs objets, les"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 4,
    "type": "paragraph",
    "text": "classes définissent les actions qu'ils peuvent prendre en charge et la manière dont ces actions affectent leur état"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 4,
    "type": "paragraph",
    "text": "➢ ce sont des « messages » ou des « méthodes »."
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 4,
    "type": "paragraph",
    "text": "➢ Java n'est pas le seul langage objet"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 4,
    "type": "code_line",
    "text": "➢ Simula, Smalltalk, C++, OCaml..."
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 5,
    "type": "paragraph",
    "text": "Etienne DURIS © ESIPE­MLV Université Paris­Est Marne­la­Vallée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 5,
    "type": "paragraph",
    "text": "5"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 5,
    "type": "paragraph",
    "text": "Les avantages de la programmation objet"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 5,
    "type": "paragraph",
    "text": "➢ Les caractéristiques de bases précédemment décrites peuvent"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 5,
    "type": "paragraph",
    "text": "être mises en oeuvre dans un style impératif, mais des fonctionnalités propres au style objet favorisent:"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 5,
    "type": "paragraph",
    "text": "➢ la programmation modulaire"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 5,
    "type": "paragraph",
    "text": "➢ l' abstraction"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 5,
    "type": "paragraph",
    "text": "➢ la spécialisation"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 5,
    "type": "paragraph",
    "text": "➢ L'objectif est de produire du code"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 5,
    "type": "table_row",
    "text": "➢ facile à développer, à maintenir, à faire évoluer,"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 5,
    "type": "paragraph",
    "text": "➢ réutilisable, tout ou en partie, sans avoir besoin de le dupliquer"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 5,
    "type": "paragraph",
    "text": "➢ générique, et dont les spécialisations sont transparentes"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 6,
    "type": "paragraph",
    "text": "Etienne DURIS © ESIPE­MLV Université Paris­Est Marne­la­Vallée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 6,
    "type": "paragraph",
    "text": "6"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 6,
    "type": "paragraph",
    "text": "Programmation modulaire"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 6,
    "type": "paragraph",
    "text": "➢ La conception par classes, représentant à la fois les données,"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 6,
    "type": "paragraph",
    "text": "les actions et les responsabilités des objets de cette classe, permet de bien distinguer et séparer les concepts"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 6,
    "type": "paragraph",
    "text": "➢ Le fait de définir des « interfaces »,"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 6,
    "type": "paragraph",
    "text": "au sens « moyens et modalités de communication avec l'extérieur » permet de cacher les détails d' implémentation et d'éviter les dépendances trop fortes"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 6,
    "type": "paragraph",
    "text": "➢ Tout ça favorise la réutilisabilité et"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 6,
    "type": "diagram_element",
    "text": "la composition / délégation : l'assemblage des composants en respectant leurs responsabilités"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 7,
    "type": "paragraph",
    "text": "Etienne DURIS © ESIPE­MLV Université Paris­Est Marne­la­Vallée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 7,
    "type": "paragraph",
    "text": "7"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 7,
    "type": "paragraph",
    "text": "L'abstraction et la spécialisation"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 7,
    "type": "paragraph",
    "text": "➢ L' abstraction demande à séparer la définition (d'un type,"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 7,
    "type": "paragraph",
    "text": "d'une classe, d'une méthode) de l'implémentation"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 7,
    "type": "paragraph",
    "text": "➢ Permet d'identifier un modèle commun à plusieurs composants"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 7,
    "type": "paragraph",
    "text": "➢ Ce modèle commun pourra être partagé"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 7,
    "type": "paragraph",
    "text": "via le mécanisme d' héritage"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 7,
    "type": "paragraph",
    "text": "➢ La spécialisation traite"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 7,
    "type": "section",
    "text": "des cas particuliers, mais elle doit autant que possible rester transparente:"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 7,
    "type": "paragraph",
    "text": "➢ C'est possible grâce"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 7,
    "type": "paragraph",
    "text": "à la dérivation"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 7,
    "type": "paragraph",
    "text": "?"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 8,
    "type": "paragraph",
    "text": "Etienne DURIS © ESIPE­MLV Université Paris­Est Marne­la­Vallée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 8,
    "type": "paragraph",
    "text": "8"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 8,
    "type": "section",
    "text": "Le langage Java:"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 8,
    "type": "paragraph",
    "text": "➢ est né en 1995 chez Sun Microsystems"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 8,
    "type": "paragraph",
    "text": "➢ Version actuelle Java 8, actuellement Oracle"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 8,
    "type": "paragraph",
    "text": "➢ est orienté objet"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 8,
    "type": "paragraph",
    "text": "➢ est fortement typé"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 8,
    "type": "paragraph",
    "text": "➢ Toute variable doit être déclarée avec un type"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 8,
    "type": "paragraph",
    "text": "➢ Le compilateur vérifie que les utilisations des variables sont"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 8,
    "type": "paragraph",
    "text": "compatibles avec leur type (notamment via un sous­typage correct)"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 8,
    "type": "paragraph",
    "text": "➢ Les types sont d'une part fournis par le langage, mais également par"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 8,
    "type": "paragraph",
    "text": "la définition des classes"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 8,
    "type": "paragraph",
    "text": "➢ est compilé"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 8,
    "type": "paragraph",
    "text": "➢ En bytecode, i.e., code intermédiaire indépendant de la machine"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 8,
    "type": "paragraph",
    "text": "➢ est interprété"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 8,
    "type": "paragraph",
    "text": "➢ Le bytecode est interpété par une machine virtuelle Java"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 9,
    "type": "paragraph",
    "text": "Etienne DURIS © ESIPE­MLV Université Paris­Est Marne­la­Vallée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 9,
    "type": "paragraph",
    "text": "9"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 9,
    "type": "paragraph",
    "text": "Premier exemple"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 9,
    "type": "paragraph",
    "text": "➢ Dans un fichier de nom HelloWorld.java"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 9,
    "type": "diagram_element",
    "text": "➢ Règle: toute classe publique doit être dans un fichier qui a le"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 9,
    "type": "paragraph",
    "text": "même nom que la classe"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 9,
    "type": "diagram_element",
    "text": "➢ Règle: tout code doit être à l'intérieur d'une classe"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 9,
    "type": "paragraph",
    "text": "➢ Ça définit une classe, qui est une unité de compilation"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 9,
    "type": "paragraph",
    "text": "➢ Comme il y a une méthode main , cette classe est « exécutable »"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 9,
    "type": "code_line",
    "text": "public class HelloWorld { /* Un style de commentaire sur plusieurs lignes. */ public static void main(String args) { // Un commentaire sur une seule ligne System. out .println( \"Bonjour à vous les IR1!\" ); } }"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 10,
    "type": "paragraph",
    "text": "Etienne DURIS © ESIPE­MLV Université Paris­Est Marne­la­Vallée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 10,
    "type": "paragraph",
    "text": "10"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 10,
    "type": "paragraph",
    "text": "Compilation, bytecode et JVM"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 10,
    "type": "paragraph",
    "text": "➢ Compilation du langage source ­> exécution du bytecode"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 10,
    "type": "paragraph",
    "text": "Fichier HelloWorld.java"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 10,
    "type": "code_line",
    "text": "public class HelloWorld { /* Un style de commentaire sur plusieurs lignes. */ public static void main(String args) { // Un commentaire sur une seule ligne System.out.println(\"Bonjour à vous les IR1!\"); } }"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 10,
    "type": "paragraph",
    "text": "javac HelloWorld.java"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 10,
    "type": "paragraph",
    "text": "Fichier HelloWorld.class"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 10,
    "type": "code_line",
    "text": "Compiled from \"HelloWorld.java\" public class HelloWorld extends java.lang.Object{ public HelloWorld(); Code: 0: aload_0 1: invokespecial #1; //Method java/lang/Object.\"<init>\":()V 4: return public static void main (java.lang.String); Code: 0: getstatic #2; //Field java/lang/System.out:Ljava/io/PrintStream; 3: ldc #3; //String Bonjour à vous les IR1! 5: invokevirtual #4; //Method java/io/PrintStream.println:(Ljava/lang/String;)V 8: return }"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 10,
    "type": "paragraph",
    "text": "java HelloWorld"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 10,
    "type": "paragraph",
    "text": "Compilation (une seule fois)"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 10,
    "type": "paragraph",
    "text": "Interprétation / exécution (write once, run everywhere)"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 10,
    "type": "paragraph",
    "text": "Linux Java Virtual Machine"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 10,
    "type": "paragraph",
    "text": "Pile Tas"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 10,
    "type": "paragraph",
    "text": "Bonjour à vous les IR1!"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 10,
    "type": "paragraph",
    "text": "Windows Java Virtual Machine"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 10,
    "type": "paragraph",
    "text": "Pile Tas"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 10,
    "type": "paragraph",
    "text": "Bonjour à vous les IR1!"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 10,
    "type": "paragraph",
    "text": "java HelloWorld"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 11,
    "type": "paragraph",
    "text": "Etienne DURIS © ESIPE­MLV Université Paris­Est Marne­la­Vallée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 11,
    "type": "paragraph",
    "text": "11"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 11,
    "type": "paragraph",
    "text": "Le bytecode"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 11,
    "type": "paragraph",
    "text": "➢ Le langage source Java est défini par la JLS ( Java Language"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 11,
    "type": "paragraph",
    "text": "Specification ) éditée par Sun­Oracle"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 11,
    "type": "paragraph",
    "text": "➢ Dans sa syntaxe et sa sémantique"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 11,
    "type": "paragraph",
    "text": "➢ Le code source d'une classe contenue dans un fichier est"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 11,
    "type": "paragraph",
    "text": "compilé avec la commande javac"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 11,
    "type": "paragraph",
    "text": "➢ Cela produit un code intermédiaire, appelé bytecode, qui est le"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 11,
    "type": "paragraph",
    "text": "« langage machine » de la machine virtuelle Java"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 11,
    "type": "paragraph",
    "text": "➢ Le bytecode d'une classe est destiné à être chargé par une"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 11,
    "type": "paragraph",
    "text": "machine virtuelle qui doit l'exécuter avec la comande java"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 11,
    "type": "paragraph",
    "text": "➢ Soit par interprétation , soit par compilation « juste à temps »"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 11,
    "type": "paragraph",
    "text": "( just­in­time ou JIT)"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 11,
    "type": "paragraph",
    "text": "➢ L'argument est le nom de la classe (sans l'extension .class)"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 12,
    "type": "paragraph",
    "text": "Etienne DURIS © ESIPE­MLV Université Paris­Est Marne­la­Vallée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 12,
    "type": "paragraph",
    "text": "12"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 12,
    "type": "paragraph",
    "text": "La machine virtuelle (JVM)"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 12,
    "type": "paragraph",
    "text": "➢ Son rôle est d' abstraire le comportement d'une machine"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 12,
    "type": "paragraph",
    "text": "➢ Pour le rendre le + possible indépendant de la plateforme"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 12,
    "type": "paragraph",
    "text": "➢ Son comportement est défini par la JVM Spec édité par Sun­"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 12,
    "type": "diagram_element",
    "text": "Oracle"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 12,
    "type": "paragraph",
    "text": "➢ Une JVM est une implémentation de cette spec"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 12,
    "type": "paragraph",
    "text": "➢ Qui peut être adaptée à une plateforme d'accueil (Windows,"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 12,
    "type": "paragraph",
    "text": "Linux, Mac...)"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 12,
    "type": "diagram",
    "text": "➢ Qui peut être développée par Sun (HotSpot: open source GPL\ndepuis 2006) ou par d'autres: IBM, Jikes, etc."
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 12,
    "type": "paragraph",
    "text": "➢ Une JVM traduit le bytecode dans le langage machine de la"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 12,
    "type": "paragraph",
    "text": "plateforme d'accueil"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 13,
    "type": "paragraph",
    "text": "Etienne DURIS © ESIPE­MLV Université Paris­Est Marne­la­Vallée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 13,
    "type": "paragraph",
    "text": "13"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 13,
    "type": "diagram_element",
    "text": "Java: un langage et une plateforme"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 13,
    "type": "paragraph",
    "text": "➢ Dans la technologie Java, on a donc besoin"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 13,
    "type": "paragraph",
    "text": "➢ Du langage de programmation et du compilateur"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 13,
    "type": "diagram_element",
    "text": "➢ Et plein de commandes bien utiles: jar, javap, javadoc, etc"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 13,
    "type": "paragraph",
    "text": "➢ De la JVM et des APIs ( Application Programming Interfaces )"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 13,
    "type": "section",
    "text": "regroupées dans une « plateforme »:"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 13,
    "type": "paragraph",
    "text": "➢ Java SE (Java Platform, Standard Edition): Java SE 6 pour"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 13,
    "type": "paragraph",
    "text": "applications classiques, desktop"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 13,
    "type": "paragraph",
    "text": "➢ Java EE (Java Platform, Enterprise Edition): Java EE 6 pour"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 13,
    "type": "paragraph",
    "text": "développer et déployer des applications serveur, Web services, etc."
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 13,
    "type": "paragraph",
    "text": "➢ Java ME (Java Platform, Micro Edition): J2ME pour les applications"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 13,
    "type": "table_row",
    "text": "embarquées, PDA, téléphones, etc."
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 13,
    "type": "paragraph",
    "text": "➢ Si on veut juste exécuter, il suffit du JRE ( Java Runtime"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 13,
    "type": "paragraph",
    "text": "Execution ) par opposition au JDK ( Java Developpement Kit )"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 14,
    "type": "paragraph",
    "text": "Etienne DURIS © ESIPE­MLV Université Paris­Est Marne­la­Vallée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 14,
    "type": "paragraph",
    "text": "14"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 14,
    "type": "paragraph",
    "text": "Java SE 7 Plateform at a Glance (http://docs.oracle.com/javase/7/docs/)"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 15,
    "type": "paragraph",
    "text": "Etienne DURIS © ESIPE­MLV Université Paris­Est Marne­la­Vallée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 15,
    "type": "paragraph",
    "text": "15"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 15,
    "type": "paragraph",
    "text": "Le langage Java"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 15,
    "type": "table_row",
    "text": "➢ Les variables, les opérateurs, les expressions, instructions,"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 15,
    "type": "paragraph",
    "text": "blocs, contrôle de flot sont très proches de ceux du C"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 15,
    "type": "paragraph",
    "text": "➢ Les exceptions sont une nouveauté"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 15,
    "type": "paragraph",
    "text": "➢ Les types primitifs ont une taille et une représentation normée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 15,
    "type": "paragraph",
    "text": "➢ S'y ajoutent des spécificités syntaxiques liées à la"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 15,
    "type": "paragraph",
    "text": "programmation objet, aux classes, à l'héritage..."
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 15,
    "type": "paragraph",
    "text": "➢ Un style de nommage (très fortement) conseillé"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 15,
    "type": "paragraph",
    "text": "➢ Style « chameau » ( CamelCase ) pour les indentificateurs"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 15,
    "type": "paragraph",
    "text": "➢ Première majuscule pour les classes ( class HelloWorld )"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 15,
    "type": "paragraph",
    "text": "➢ Première minuscule pour les variables/champs et les"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 15,
    "type": "paragraph",
    "text": "fonctions/méthodes ( radius, getRadius() )"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 15,
    "type": "paragraph",
    "text": "➢ Tout en majuscule pour les constantes ( MAX_SIZE )"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 16,
    "type": "paragraph",
    "text": "Etienne DURIS © ESIPE­MLV Université Paris­Est Marne­la­Vallée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 16,
    "type": "paragraph",
    "text": "16"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 16,
    "type": "paragraph",
    "text": "Classes et objets"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 16,
    "type": "section",
    "text": "➢ Une classe Toto représente plusieurs choses:"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 16,
    "type": "paragraph",
    "text": "➢ Une unité de compilation"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 16,
    "type": "paragraph",
    "text": "➢ La compilation d'un programme qui contient une classe Toto"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 16,
    "type": "paragraph",
    "text": "produira un fichier Toto.class"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 16,
    "type": "paragraph",
    "text": "➢ La définition du type Toto"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 16,
    "type": "code_line",
    "text": "➢ Il peut servir à déclarer des variables comme Toto t;"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 16,
    "type": "paragraph",
    "text": "➢ Un moule pour la création d'objets de type Toto"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 16,
    "type": "paragraph",
    "text": "➢ Cela nécessite en général la définition d'un ensemble de champs"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 16,
    "type": "paragraph",
    "text": "( fields ) décrivant l'état d'un objet de ce type et d'un ensemble de méthodes définissant son comportement ou ses focntionnalités"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 16,
    "type": "paragraph",
    "text": "➢ Chaque objet de la classe Toto"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 16,
    "type": "paragraph",
    "text": "➢ Dispose de son propre état (la valeur de ses champs)"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 16,
    "type": "paragraph",
    "text": "➢ Répond au même comportement (via les méthodes de la classe)"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 17,
    "type": "paragraph",
    "text": "Etienne DURIS © ESIPE­MLV Université Paris­Est Marne­la­Vallée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 17,
    "type": "paragraph",
    "text": "17"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 17,
    "type": "paragraph",
    "text": "Structure d'une classe"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 17,
    "type": "paragraph",
    "text": "➢ Une classe est définie par son nom et son package"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 17,
    "type": "diagram_element",
    "text": "d'appartenance (ex: java.lang.String )"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 17,
    "type": "paragraph",
    "text": "➢ En l'absence de directive, les classes sont dans un package dit"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 17,
    "type": "paragraph",
    "text": "« par défaut » (i.e., pas de packge)."
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 17,
    "type": "paragraph",
    "text": "➢ Une classe peut contenir trois sortes de membres"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 17,
    "type": "paragraph",
    "text": "➢ Des champs (fields) ou attributs"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 17,
    "type": "paragraph",
    "text": "➢ Des méthodes (methods) et constructeurs"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 17,
    "type": "paragraph",
    "text": "➢ Des classes internes"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 17,
    "type": "paragraph",
    "text": "➢ Les membres statiques ( static ) sont dits membres de classe"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 17,
    "type": "paragraph",
    "text": "➢ Ils sont définis sur la classe et non sur les objets"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 17,
    "type": "paragraph",
    "text": "➢ Les membres non statiques (ou d'instance ) ne peuvent exister"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 17,
    "type": "paragraph",
    "text": "sans un objet"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 18,
    "type": "paragraph",
    "text": "Etienne DURIS © ESIPE­MLV Université Paris­Est Marne­la­Vallée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 18,
    "type": "paragraph",
    "text": "18"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 18,
    "type": "diagram_element",
    "text": "Exemple"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 18,
    "type": "code_block",
    "text": "public class Pixel {\npublic final static int ORIGIN = 0; private int x ; private int y ; public Pixel( int x, int y) {\nthis . x = x; this . y = y; } public void reset() {\nx = ORIGIN ; y = ORIGIN ; } public void printOnScreen() {\nSystem. out .println( \"(\" + x + \",\" + y + \")\" ); } public static boolean same(Pixel p1, Pixel p2) {\nreturn (p1. x ==p2. x ) && (p1. y ==p2. y ); } public static void main(String args) {\nPixel p0 = new Pixel(0,0); Pixel p1 = new Pixel(1,3); p1.printOnScreen(); // (1,3) System. out .println( same (p0,p1)); // false p1.reset(); System. out .println( same (p0,p1)); // true } }"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 18,
    "type": "diagram_element",
    "text": "Constructeur"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 18,
    "type": "paragraph",
    "text": "Méthodes d'instances"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 18,
    "type": "diagram",
    "text": "Champs\nConstante"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 18,
    "type": "paragraph",
    "text": "Méthode de classe"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 18,
    "type": "paragraph",
    "text": "Variables locales"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 18,
    "type": "paragraph",
    "text": "à la méthode"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 18,
    "type": "paragraph",
    "text": "main et objets de la"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 18,
    "type": "paragraph",
    "text": "classe Pixel"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 19,
    "type": "paragraph",
    "text": "Etienne DURIS © ESIPE­MLV Université Paris­Est Marne­la­Vallée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 19,
    "type": "paragraph",
    "text": "19"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 19,
    "type": "paragraph",
    "text": "Les objets sont manipulés via des références (sortes d'adresses mémoire)"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 19,
    "type": "code_block",
    "text": "public void reset() {\n#1.x = #s ; #1.y = #s ; }\npublic void reset() {\nx = ORIGIN ; y = ORIGIN ; }\np1.reset();"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 19,
    "type": "paragraph",
    "text": "Lorsque la méthode"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 19,
    "type": "paragraph",
    "text": "est appelée, le code de la méthode défini dans la classe comme"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 19,
    "type": "paragraph",
    "text": "est exécuté sur la pile avec les références #1 à la place de p1 et #s à la place de ORIGIN"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 19,
    "type": "paragraph",
    "text": "Ce qui a pour effet de mettre p1.x et p1.y à 0"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 19,
    "type": "code_line",
    "text": "y = 0"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 19,
    "type": "paragraph",
    "text": "Classe Pixel"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 19,
    "type": "paragraph",
    "text": "constructeur"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 19,
    "type": "paragraph",
    "text": "méthodes"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 19,
    "type": "paragraph",
    "text": "main"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 19,
    "type": "code_line",
    "text": "x = 0"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 19,
    "type": "paragraph",
    "text": "Pixel p1"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 19,
    "type": "code_block",
    "text": "y = 3\nx = 1 Pixel p2\n#1\n#2\nORIGIN = 0 #s"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 19,
    "type": "paragraph",
    "text": "0 0"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 19,
    "type": "paragraph",
    "text": "@ class Pixel"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 19,
    "type": "paragraph",
    "text": "@ class Pixel"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 19,
    "type": "paragraph",
    "text": "Chaque objet connait sa classe"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 19,
    "type": "code_block",
    "text": "#1\n#2"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 20,
    "type": "paragraph",
    "text": "Etienne DURIS © ESIPE­MLV Université Paris­Est Marne­la­Vallée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 20,
    "type": "paragraph",
    "text": "20"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 20,
    "type": "paragraph",
    "text": "La nature des variables en Java"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 20,
    "type": "paragraph",
    "text": "➢ Les variables locales comme les champs des classes et des"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 20,
    "type": "paragraph",
    "text": "objets ne peuvent être que de deux natures"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 20,
    "type": "paragraph",
    "text": "➢ De type « primitif »"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 20,
    "type": "paragraph",
    "text": "➢ Dans ce cas, la déclaration de la variable réserve la place"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 20,
    "type": "paragraph",
    "text": "mémoire pour stocker sa valeur (qui dépend de son type)"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 20,
    "type": "paragraph",
    "text": "➢ De type « objet », ou référence"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 20,
    "type": "paragraph",
    "text": "➢ Dans ce cas, la déclaration de la variable ne fait que réserver la"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 20,
    "type": "paragraph",
    "text": "place d'une référence (une sorte de pointeur) qui permettra d'accéder à l'endroit en mémoire où est effectivement stocké l'objet en lui­même (vaut null si référence inconnue)"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 20,
    "type": "code_block",
    "text": "Pixel p1;\ny = 3\nx = 1\n#1\nint entier; long entierLong;"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 20,
    "type": "paragraph",
    "text": "@ class Pixel"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 20,
    "type": "code_line",
    "text": "p1=new Pixel(1,3); #1"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 20,
    "type": "paragraph",
    "text": "référence"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 20,
    "type": "paragraph",
    "text": "objet"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 21,
    "type": "paragraph",
    "text": "Etienne DURIS © ESIPE­MLV Université Paris­Est Marne­la­Vallée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 21,
    "type": "paragraph",
    "text": "21"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 21,
    "type": "paragraph",
    "text": "Les types primitifs"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 21,
    "type": "paragraph",
    "text": "➢ Types entiers signés (représentation en complément à 2)"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 21,
    "type": "paragraph",
    "text": "➢ byte (octet) sur 8 bits: [­128 .. 127]"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 21,
    "type": "paragraph",
    "text": "➢ short sur 16 bits [­32768 .. 32767]"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 21,
    "type": "paragraph",
    "text": "➢ int sur 32 bits [­2147483648 .. 2147483647] (défaut pour entiers)"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 21,
    "type": "paragraph",
    "text": "➢ long sur 64 bits [ ­9223372036854775808 .. 9223372036854775807 ]"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 21,
    "type": "paragraph",
    "text": "➢ Type caractère non signé (unités de code UTF­16)"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 21,
    "type": "paragraph",
    "text": "➢ char sur 16 bits ['\\u0000' .. '\\uffff']"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 21,
    "type": "paragraph",
    "text": "➢ Types à virgule flottante (représentation IEEE 754)"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 21,
    "type": "paragraph",
    "text": "➢ float sur 32 bits"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 21,
    "type": "paragraph",
    "text": "➢ double sur 64 bits (défaut pour flottants)"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 21,
    "type": "diagram_element",
    "text": "➢ Type booléen: boolean ( true ou false )"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 22,
    "type": "paragraph",
    "text": "Etienne DURIS © ESIPE­MLV Université Paris­Est Marne­la­Vallée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 22,
    "type": "paragraph",
    "text": "22"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 22,
    "type": "paragraph",
    "text": "Promotion entière et flottants spéciaux"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 22,
    "type": "paragraph",
    "text": "➢ Pour la plupart des opérations, les valeurs entières sont"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 22,
    "type": "section",
    "text": "transformés en des « int » (promotion entière):"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 22,
    "type": "code_block",
    "text": "➢ short s = 4;\ns = s+s; // Type mismatch: cannot convert int to short s = (short) (s+s); // cast nécessaire"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 22,
    "type": "paragraph",
    "text": "➢ Les débordements ou cas d'erreurs sont prévus pour les"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 22,
    "type": "code_block",
    "text": "flottants (Infinity et Not­a­Number):\n➢ double d = 1e308;\nSystem.out.println(d*10); // affiche: Infinity\n➢ d = 0.0/0.0;\nSystem.out.println(d); // affiche: NaN"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 23,
    "type": "paragraph",
    "text": "Etienne DURIS © ESIPE­MLV Université Paris­Est Marne­la­Vallée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 23,
    "type": "paragraph",
    "text": "23"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 23,
    "type": "paragraph",
    "text": "Attention aux nombres à virgule flottante"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 23,
    "type": "paragraph",
    "text": "➢ Ils ne sont que des approximation des valeurs"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 23,
    "type": "code_line",
    "text": "➢ Leur égalité au sens de l'opérateur == n'a aucun sens"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 23,
    "type": "paragraph",
    "text": "➢ Il faut tester leur « proximité » modulo un epsilon donné"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 23,
    "type": "code_block",
    "text": "double d = 0.0; int nb = 0; double expected = 1.0; while (d != 1.0 /* && nb < 10 */ ) { // boucle infinie!!!\nd += 0.1; nb++; } System. out .println( \"nb: \" + nb + \" d: \" + d); // Si on décommente, affiche nb: 10 d: 0.9999999999999999\nstatic final double EPSILON = 0.00001; ... double d = 0.0; double expected = 1.0; while ( Math. abs (expected – d) > EPSILON )\nd += 0.1; System. out .println(d); // 0.9999999999999999"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 24,
    "type": "paragraph",
    "text": "Etienne DURIS © ESIPE­MLV Université Paris­Est Marne­la­Vallée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 24,
    "type": "paragraph",
    "text": "24"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 24,
    "type": "paragraph",
    "text": "Tous les autres types sont « objets » et sont manipulés via des références"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 24,
    "type": "paragraph",
    "text": "➢ soit des types définis dans les APIs"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 24,
    "type": "table_row",
    "text": "➢ java.lang.Object, java.lang.String,java.util.Scanner, etc."
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 24,
    "type": "code_line",
    "text": "➢ String chaine = \"toto\";"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 24,
    "type": "paragraph",
    "text": "➢ Différent du C!"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 24,
    "type": "paragraph",
    "text": "➢ En plus, les String sont constantes"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 24,
    "type": "paragraph",
    "text": "➢ soit des types « cachés »"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 24,
    "type": "paragraph",
    "text": "➢ Tableau de types primitifs ou d'autres types « objets »"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 24,
    "type": "code_block",
    "text": "➢ int tab = {3, 5, 7, 9};\n➢ String args;\n➢ Pixel array = new Pixel[2];"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 24,
    "type": "paragraph",
    "text": "➢ soit des types définis par l'utilisateur"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 24,
    "type": "code_line",
    "text": "➢ Pixel p = new Pixel(0,0);"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 24,
    "type": "paragraph",
    "text": "t o"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 24,
    "type": "code_block",
    "text": "#2\n#1 @class String #1"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 24,
    "type": "paragraph",
    "text": "t o \\n #2"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 24,
    "type": "code_block",
    "text": "length = 4\n#1 @class int #1"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 24,
    "type": "paragraph",
    "text": "3"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 24,
    "type": "paragraph",
    "text": "5"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 24,
    "type": "paragraph",
    "text": "7"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 24,
    "type": "paragraph",
    "text": "9"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 24,
    "type": "paragraph",
    "text": "..."
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 24,
    "type": "code_block",
    "text": "length = 2\n#2 @class Pixel\n#2"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 24,
    "type": "paragraph",
    "text": "null"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 24,
    "type": "paragraph",
    "text": "null"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 24,
    "type": "paragraph",
    "text": "null"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 25,
    "type": "paragraph",
    "text": "Etienne DURIS © ESIPE­MLV Université Paris­Est Marne­la­Vallée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 25,
    "type": "paragraph",
    "text": "25"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 25,
    "type": "paragraph",
    "text": "Types Java et passage de paramètre"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 25,
    "type": "paragraph",
    "text": "➢ Lors des appels de méthode, les arguments sont toujours"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 25,
    "type": "paragraph",
    "text": "passés par valeur"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 25,
    "type": "paragraph",
    "text": "➢ Dans le cas des types primitifs , c'est la valeur de l'argument"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 25,
    "type": "paragraph",
    "text": "qui est recopiée dans le paramètre de la méthode"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 25,
    "type": "paragraph",
    "text": "➢ Les modifications sur le paramètre de la méthode sont sans"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 25,
    "type": "paragraph",
    "text": "effet sur l'argument"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 25,
    "type": "paragraph",
    "text": "➢ Dans le cas des types « objet » , c'est la valeur de la variable,"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 25,
    "type": "paragraph",
    "text": "(la référence à l'objet) qui est transmise à la méthode"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 25,
    "type": "paragraph",
    "text": "➢ Les modifications effectuées en suivant cette référence (e.g."
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 25,
    "type": "paragraph",
    "text": "modification d'un champ de l'objet) sont répercutés dans la mémoire et sont donc visibles sur l'argument"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 25,
    "type": "paragraph",
    "text": "➢ En revanche, la modification de la référence elle­même est"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 25,
    "type": "paragraph",
    "text": "sans effet sur l'argument (c'en est une copie)"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 26,
    "type": "paragraph",
    "text": "Etienne DURIS © ESIPE­MLV Université Paris­Est Marne­la­Vallée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 26,
    "type": "paragraph",
    "text": "26"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 26,
    "type": "diagram_element",
    "text": "Passage de paramètre: type primitif"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 26,
    "type": "code_block",
    "text": "public static void m1( int i) {\ni++; }\npublic static void main(String args) {\nint entier = 5; m1 (entier); System. out .println(entier); // 5 }"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 26,
    "type": "paragraph",
    "text": "5 entier"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 26,
    "type": "paragraph",
    "text": "5 i 6"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 26,
    "type": "paragraph",
    "text": "➢ Dans le cas des types primitifs , c'est la valeur de l'argument"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 26,
    "type": "paragraph",
    "text": "qui est recopiée dans le paramètre de la méthode"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 26,
    "type": "paragraph",
    "text": "➢ Les modifications sur le paramètre de la méthode sont sans"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 26,
    "type": "paragraph",
    "text": "effet sur l'argument"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 27,
    "type": "paragraph",
    "text": "Etienne DURIS © ESIPE­MLV Université Paris­Est Marne­la­Vallée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 27,
    "type": "paragraph",
    "text": "27"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 27,
    "type": "diagram_element",
    "text": "Passage de paramètre: type référence"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 27,
    "type": "code_block",
    "text": "public static void m2(Box b) {\nb. field ++; }\npublic static void main(String args) {\nBox box = new Box(); box. field = 5; m2 (box); System. out .println(box. field ); // 6 }\nclass Box {\nint field ; }"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 27,
    "type": "paragraph",
    "text": "box"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 27,
    "type": "paragraph",
    "text": "b"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 27,
    "type": "paragraph",
    "text": "6"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 27,
    "type": "code_block",
    "text": "#1 @class Box\n#1\nfield = 5 #1"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 27,
    "type": "paragraph",
    "text": "➢ Dans le cas des types « objet » , c'est la valeur de la variable,"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 27,
    "type": "paragraph",
    "text": "(la référence à l'objet) qui est transmise à la méthode"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 27,
    "type": "paragraph",
    "text": "➢ Les modifications effectuées en suivant cette référence (e.g."
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 27,
    "type": "paragraph",
    "text": "modification d'un champ de l'objet) sont répercutés dans la mémoire et sont donc visibles sur l'argument"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 28,
    "type": "paragraph",
    "text": "Etienne DURIS © ESIPE­MLV Université Paris­Est Marne­la­Vallée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 28,
    "type": "paragraph",
    "text": "28"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 28,
    "type": "diagram_element",
    "text": "Passage de paramètre: type référence"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 28,
    "type": "code_block",
    "text": "public static void m3(Box b) {\nBox tmp = new Box(); tmp. field = b. field +1; b = tmp; } public static void main(String args) {\nBox box = new Box(); box. field = 5; m3 (box); System. out .println(box. field ); // 5 }\nclass Box {\nint field ; }"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 28,
    "type": "paragraph",
    "text": "box"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 28,
    "type": "paragraph",
    "text": "b #1 @class Box"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 28,
    "type": "code_block",
    "text": "#1\nfield = 5 #1"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 28,
    "type": "paragraph",
    "text": "➢ Dans le cas des types « objet » , c'est la valeur de la variable,"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 28,
    "type": "paragraph",
    "text": "(la référence à l'objet) qui est transmise à la méthode"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 28,
    "type": "paragraph",
    "text": "➢ En revanche, la modification de la référence elle­même est"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 28,
    "type": "paragraph",
    "text": "sans effet sur l'argument (c'en est une copie)"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 28,
    "type": "code_block",
    "text": "#2 @class Box\nfield = 6 tmp #2\n#2"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 29,
    "type": "paragraph",
    "text": "Etienne DURIS © ESIPE­MLV Université Paris­Est Marne­la­Vallée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 29,
    "type": "paragraph",
    "text": "29"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 29,
    "type": "code_line",
    "text": "Type référence et valeur null"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 29,
    "type": "paragraph",
    "text": "➢ Lorsqu'on déclare une variable de type objet, seule la place de"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 29,
    "type": "paragraph",
    "text": "la référence est réservée sur la pile d'exécution (registre)"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 29,
    "type": "paragraph",
    "text": "➢ 4 octets, 32 bits, et ce quelque soit le type de l'objet référencé"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 29,
    "type": "paragraph",
    "text": "➢ Par défaut, cette référence vaut une valeur particulière, null ."
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 29,
    "type": "paragraph",
    "text": "➢ Il est interdit de tenter d'y accéder, de la déréférencer"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 29,
    "type": "paragraph",
    "text": "➢ Le compilateur vérifie ce qu'il peut"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 29,
    "type": "paragraph",
    "text": "➢ On peut « forcer » pour que ça compile => lève une exception"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 29,
    "type": "code_block",
    "text": "public static void main(String args) {\nBox b; System. out .println(b. field ); // Variable b might not have been initialized }\npublic static void main(String args) {\nBox b = null ; System. out .println(b. field ); // lève NullPointerException"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 30,
    "type": "paragraph",
    "text": "Etienne DURIS © ESIPE­MLV Université Paris­Est Marne­la­Vallée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 30,
    "type": "paragraph",
    "text": "30"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 30,
    "type": "paragraph",
    "text": "Allocation mémoire"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 30,
    "type": "paragraph",
    "text": "➢ Pour qu'une variable objet prenne une autre valeur que null, il"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 30,
    "type": "paragraph",
    "text": "faut être capable d'y affecter une référence"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 30,
    "type": "paragraph",
    "text": "➢ Elle peut être produite (retournée) par l'opérateur d'allocation new"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 30,
    "type": "paragraph",
    "text": "➢ Cet opérateur à besoin de connaître la taille de l'objet qu'il doit"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 30,
    "type": "paragraph",
    "text": "réserver en mémoire"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 30,
    "type": "paragraph",
    "text": "➢ Le nom du type / de la classe suit immédiatement l'opérateur"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 30,
    "type": "paragraph",
    "text": "➢ new Box(); // j'ai besoin de stocker 1 int (field)"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 30,
    "type": "code_line",
    "text": "➢ new int[10]; // stocker 10 int + la taille du tableau"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 30,
    "type": "paragraph",
    "text": "➢ La zone mémoire allouée doit être initialisée (affectation des valeurs)"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 30,
    "type": "paragraph",
    "text": "➢ new Pixel(1,3); // utilise un « constructeur »"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 30,
    "type": "diagram_element",
    "text": "➢ Le terme de constructeur est mal choisi: initialiseur serait mieux"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 30,
    "type": "paragraph",
    "text": "➢ Ce que retourne l'opérateur new est la référence qui permet"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 30,
    "type": "paragraph",
    "text": "d'accéder à l'objet alloué en mémoire"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 31,
    "type": "paragraph",
    "text": "Etienne DURIS © ESIPE­MLV Université Paris­Est Marne­la­Vallée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 31,
    "type": "paragraph",
    "text": "31"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 31,
    "type": "paragraph",
    "text": "Désallocation mémoire"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 31,
    "type": "paragraph",
    "text": "➢ Elle n'est pas gérée par le programmeur, mais par un GC"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 31,
    "type": "paragraph",
    "text": "(Garbage Collector)"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 31,
    "type": "paragraph",
    "text": "➢ Les objets qui ne sont plus référencés peuvent être"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 31,
    "type": "paragraph",
    "text": "« récupérés » par le GC, pour « recycler » l'espace mémoire qu'ils occupent"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 31,
    "type": "paragraph",
    "text": "➢ Un même objet peut être référencé par plusieurs variables"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 31,
    "type": "paragraph",
    "text": "➢ Il faut qu'aucune variable ne référence plus un objet pour qu'il"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 31,
    "type": "paragraph",
    "text": "soit réclamé"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 31,
    "type": "paragraph",
    "text": "➢ Les variables cessent de référencer un objet"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 31,
    "type": "paragraph",
    "text": "➢ Quand on leur affecte une autre valeur, ou null"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 31,
    "type": "diagram_element",
    "text": "➢ Quand on quitte le bloc où elles ont été définies: elles meurent,"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 31,
    "type": "paragraph",
    "text": "disparaissent... (sur la pile)"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 32,
    "type": "paragraph",
    "text": "Etienne DURIS © ESIPE­MLV Université Paris­Est Marne­la­Vallée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 32,
    "type": "paragraph",
    "text": "32"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 32,
    "type": "paragraph",
    "text": "Références et Garbage Collector"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 32,
    "type": "paragraph",
    "text": "➢ La quantitié de mémoire disponible dans le tas de la VM est fixé"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 32,
    "type": "section",
    "text": "à l'avance (paramétrable):"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 32,
    "type": "paragraph",
    "text": "➢ java ­Xms<size> MyAppli"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 32,
    "type": "paragraph",
    "text": "➢ C'est le gestionnaire de la mémoire qui se charge de"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 32,
    "type": "paragraph",
    "text": "➢ L'allocation des nouveaux objets"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 32,
    "type": "paragraph",
    "text": "➢ Demandée par l'opérateur new"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 32,
    "type": "paragraph",
    "text": "➢ La récupération de la place occupée par les objets morts"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 32,
    "type": "paragraph",
    "text": "(devenus inaccessibles)"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 32,
    "type": "paragraph",
    "text": "➢ Lorsqu'il y a besoin de place supplémentaire ou quand il le décide"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 32,
    "type": "paragraph",
    "text": "➢ De la manière d'organiser les objets"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 32,
    "type": "paragraph",
    "text": "➢ Pour éviter une « fragmentation « de la mémoire, il « déplace » les"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 32,
    "type": "paragraph",
    "text": "objets en mémoire (zone des « vieux » des « récents », etc.)"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 32,
    "type": "paragraph",
    "text": "➢ Les références ne sont pas des adresses (indirection)"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 33,
    "type": "paragraph",
    "text": "Etienne DURIS © ESIPE­MLV Université Paris­Est Marne­la­Vallée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 33,
    "type": "paragraph",
    "text": "33"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 33,
    "type": "paragraph",
    "text": "Regardons les classes de plus près"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 33,
    "type": "paragraph",
    "text": "➢ « Avant » la classe, il peut y avoir 2 informations"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 33,
    "type": "section",
    "text": "➢ Le paquetage d'appartenance de la classe:"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 33,
    "type": "code_line",
    "text": "➢ package fr.umlv.ir1.basics;"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 33,
    "type": "paragraph",
    "text": "➢ Il permet de définir un « espace de nommage » qui donne un nom"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 33,
    "type": "diagram_element",
    "text": "complet à la classe: fr.umlv.ir1.basics.MyClass"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 33,
    "type": "paragraph",
    "text": "➢ L'organisation des classes dans les répertoires du système de fichier"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 33,
    "type": "diagram_element",
    "text": "doivent refléter l'organisation des paquetages: le répertoire fr/umlv/ir1/basics contient la classe MyClass.java"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 33,
    "type": "paragraph",
    "text": "➢ Des directives d'importation (là où aller chercher les classes dont"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 33,
    "type": "paragraph",
    "text": "on se sert dans le code); ce n'est pas une directive d'inclusion!"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 33,
    "type": "code_block",
    "text": "➢ import java.io.*;\nimport java.util.Scanner;"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 33,
    "type": "paragraph",
    "text": "➢ Les classes du paquetage java.lang sont visibles par défaut"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 34,
    "type": "paragraph",
    "text": "Etienne DURIS © ESIPE­MLV Université Paris­Est Marne­la­Vallée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 34,
    "type": "paragraph",
    "text": "34"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 34,
    "type": "paragraph",
    "text": "Quelques règles d'hygiène"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 34,
    "type": "diagram",
    "text": "➢ (Très vite) indispensable: regrouper les classes en paquetages\n➢ Obligatoire: avoir une hiérarchie de répertoire isomorphe à la"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 34,
    "type": "paragraph",
    "text": "hiérarchie des paquetages"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 34,
    "type": "paragraph",
    "text": "➢ Séparer les sources des classes"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 34,
    "type": "paragraph",
    "text": "➢ [code$] ls classes src [code$] ls src/fr/umlv/ir1/basics/ HelloWorld.java Pixel.java [code$] javac ­d classes src/fr/umlv/ir1/basics/Pixel.java [code$] ls classes/fr/umlv/ir1/basics/ Pixel.class [code$] java ­cp classes/ fr.umlv.ir1.basics.Pixel (1,3) false true [code$] javac ­cp classes ­d classes src/fr/umlv/ir1/basics/HelloWorld.java [code$] java ­cp classes/ fr.umlv.ir1.basics.HelloWorld Bonjour à vous les IR1! (1,3) false true"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 34,
    "type": "diagram",
    "text": "­d : répertoire de destination des classes\n­cp : répertoire où trouver"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 34,
    "type": "paragraph",
    "text": "les classes compilées"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 34,
    "type": "paragraph",
    "text": "Les deux si la compilation"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 34,
    "type": "paragraph",
    "text": "a besoin d'autres classes"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 35,
    "type": "paragraph",
    "text": "Etienne DURIS © ESIPE­MLV Université Paris­Est Marne­la­Vallée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 35,
    "type": "paragraph",
    "text": "35"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 35,
    "type": "diagram_element",
    "text": "La classe en elle­même: accessibilité"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 35,
    "type": "paragraph",
    "text": "➢ class MyClass"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 35,
    "type": "paragraph",
    "text": "➢ La classe sera accessible depuis toutes les classes du même"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 35,
    "type": "paragraph",
    "text": "paquetage qu'elle (on parle quelque fois de visibilité de paquetage )"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 35,
    "type": "paragraph",
    "text": "➢ public class MyClass"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 35,
    "type": "paragraph",
    "text": "➢ La classe sera accessible de n'importe où (pourvu qu'on indique"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 35,
    "type": "paragraph",
    "text": "son nom de paquetage complet ou qu'on utilise la directive import )"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 35,
    "type": "paragraph",
    "text": "➢ Cette notion d'accessibilité sert à définir des « composants » de"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 35,
    "type": "paragraph",
    "text": "plus grande granularité que les classes,"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 35,
    "type": "paragraph",
    "text": "➢ Permet de limiter l'accès"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 35,
    "type": "paragraph",
    "text": "➢ Peut éviter des conflits de noms"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 36,
    "type": "paragraph",
    "text": "Etienne DURIS © ESIPE­MLV Université Paris­Est Marne­la­Vallée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 36,
    "type": "paragraph",
    "text": "36"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 36,
    "type": "diagram_element",
    "text": "Les membres: champs et méthodes"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 36,
    "type": "paragraph",
    "text": "➢ Dans une classe, il y a grossièrement"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 36,
    "type": "paragraph",
    "text": "➢ Une zone avec des déclarations de champs"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 36,
    "type": "paragraph",
    "text": "➢ Ils définissent ce qui sera stocké dans chaque objet de cette classe"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 36,
    "type": "paragraph",
    "text": "➢ Une zone avec des déclarations de méthodes"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 36,
    "type": "paragraph",
    "text": "➢ Elles définissent les actions/fonctionnalités/comportements acceptés"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 36,
    "type": "paragraph",
    "text": "par les objets de cette classe"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 36,
    "type": "section",
    "text": "➢ Chaque méthode à deux parties:"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 36,
    "type": "paragraph",
    "text": "➢ Sa signature (type de retour, nom, types des paramètres"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 36,
    "type": "paragraph",
    "text": "➢ Son code, qui est constitué de blocs imbriqués"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 36,
    "type": "paragraph",
    "text": "➢ Il peut également y avoir aussi quelques blocs d'intitalisation,"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 36,
    "type": "paragraph",
    "text": "constructeurs ou autres classes « internes »..."
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 37,
    "type": "paragraph",
    "text": "Etienne DURIS © ESIPE­MLV Université Paris­Est Marne­la­Vallée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 37,
    "type": "paragraph",
    "text": "37"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 37,
    "type": "paragraph",
    "text": "Les blocs et les variables locales"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 37,
    "type": "paragraph",
    "text": "➢ Une variable locale est visible dans le bloc dans lequel elle est"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 37,
    "type": "paragraph",
    "text": "déclarée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 37,
    "type": "paragraph",
    "text": "➢ Les paramètres des méthodes sont considérés comme des"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 37,
    "type": "paragraph",
    "text": "variables locales"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 37,
    "type": "code_block",
    "text": "➢ 2 variables de même nom doivent être dans des blocs disjoints public class LocalVariable {\nprivate static double sum( double  values) {\ndouble sum=0.0; for ( double v:values) {\nsum+=v; } // v n'est plus accessible return sum; } // values et sum pas accessible\npublic static void main(String args) {\nsum ( new double {2,3,4,5}); } }"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 38,
    "type": "paragraph",
    "text": "Etienne DURIS © ESIPE­MLV Université Paris­Est Marne­la­Vallée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 38,
    "type": "paragraph",
    "text": "38"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 38,
    "type": "paragraph",
    "text": "Variable locale constante"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 38,
    "type": "paragraph",
    "text": "➢ Le mot­clé final signifie en Java « affectation unique »"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 38,
    "type": "paragraph",
    "text": "➢ Il s'applique sur la variable qui est déclarée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 38,
    "type": "paragraph",
    "text": "➢ Un objet ou un tableau « final » peut avoir ses champs ou ses"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 38,
    "type": "code_line",
    "text": "éléments modifiés public class FinalExample { public static void main(String args) { final int val; if (args. length ==2) val=3; else val=4; val = 0; // error: variable val might already have been assigned final String tab = args; for ( int i=0;i<args. length ;i++) tab[i]= \"toto\" ; // ok, car cela ne change pas la référence } }"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 39,
    "type": "paragraph",
    "text": "Etienne DURIS © ESIPE­MLV Université Paris­Est Marne­la­Vallée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 39,
    "type": "paragraph",
    "text": "39"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 39,
    "type": "paragraph",
    "text": "Les champs, par rapport aux variables?"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 39,
    "type": "paragraph",
    "text": "➢ Leur existence et leur durée de vie sont associées aux objets"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 39,
    "type": "paragraph",
    "text": "(ou au pire à la classe elle­même)"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 39,
    "type": "paragraph",
    "text": "➢ Tandis que les variables locales sont associées à une exécution"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 39,
    "type": "paragraph",
    "text": "de la méthode qui les utilise... sur la pile!"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 39,
    "type": "paragraph",
    "text": "➢ Les champs possèdent une valeur par défaut qui leur est"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 39,
    "type": "paragraph",
    "text": "affectée lors de la création d'un objet"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 39,
    "type": "paragraph",
    "text": "➢ 0 pour les types numériques primitifs"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 39,
    "type": "paragraph",
    "text": "➢ false pour les booléens"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 39,
    "type": "paragraph",
    "text": "➢ null pour les types référence"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 39,
    "type": "paragraph",
    "text": "➢ Tandis que les variables locales doivent nécessairement être"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 39,
    "type": "paragraph",
    "text": "initialisées avant d'être utilisées"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 40,
    "type": "paragraph",
    "text": "Etienne DURIS © ESIPE­MLV Université Paris­Est Marne­la­Vallée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 40,
    "type": "paragraph",
    "text": "40"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 40,
    "type": "paragraph",
    "text": "Accessibilité des membres"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 40,
    "type": "paragraph",
    "text": "➢ Tous les membres ont une accessibilité qui est spécifiée à la"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 40,
    "type": "paragraph",
    "text": "déclaration par un « modificateur »"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 40,
    "type": "paragraph",
    "text": "➢ De manière complémentaire à celui de la classe , il permet de"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 40,
    "type": "paragraph",
    "text": "déterminer qui, parmi ceux qui ont accès à la classe A, ont accès à ce membre"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 40,
    "type": "diagram_element",
    "text": "➢ private : accessible uniquement depuis l'intérieur de la classe A"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 40,
    "type": "paragraph",
    "text": "➢ Par défaut (pas de modificateur) : accessible depuis toutes les"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 40,
    "type": "paragraph",
    "text": "classes qui sont dans le même paquetage que A"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 40,
    "type": "diagram_element",
    "text": "➢ protected : accessible depuis toutes les classes qui sont dans"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 40,
    "type": "paragraph",
    "text": "le même paquetage que A, et également depuis celles qui ne sont pas dans le même paquetage mais qui héritent de la classe A"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 40,
    "type": "diagram_element",
    "text": "➢ public : accessible depuis n'importe où"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 41,
    "type": "paragraph",
    "text": "Etienne DURIS © ESIPE­MLV Université Paris­Est Marne­la­Vallée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 41,
    "type": "paragraph",
    "text": "41"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 41,
    "type": "diagram_element",
    "text": "Accès aux membres: champs et méthodes"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 41,
    "type": "section",
    "text": "➢ Avec le point « . » sur une référence à un objet:"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 41,
    "type": "code_line",
    "text": "➢ p.x, p0.sameAs(p1);"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 41,
    "type": "paragraph",
    "text": "➢ Le compilateur regarde"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 41,
    "type": "paragraph",
    "text": "le type déclaré de la variable (ici p ou p0 ) et vérifie que le membre (ici x ou sameAs ) existe."
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 41,
    "type": "paragraph",
    "text": "➢ Le compilateur vérifie"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 41,
    "type": "paragraph",
    "text": "également les droits d'accessibilité"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 41,
    "type": "paragraph",
    "text": "➢ Un champ et une"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 41,
    "type": "paragraph",
    "text": "méthode peuvent avoir le même nom"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 41,
    "type": "paragraph",
    "text": "➢ this représente"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 41,
    "type": "paragraph",
    "text": "l'instance courante"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 41,
    "type": "code_block",
    "text": "public class Pixel { private int x ; private int y ; public Pixel( int x, int y) { this . x = x; this . y = y; } public boolean sameAs(Pixel p) { return (this. x ==p. x ) && (this. y ==p. y ); } public static void main(String args) { Pixel p0 = new Pixel(0,0); Pixel p1 = new Pixel(1,3); boolean b = p0. sameAs (p1); // false } }\nclass OtherClass { public static void main(String args) { Pixel p0 = new Pixel(0,0); p.sameAs(p); // true p0.x = 1; // error: x has private } // access in Pixel }"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 42,
    "type": "paragraph",
    "text": "Etienne DURIS © ESIPE­MLV Université Paris­Est Marne­la­Vallée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 42,
    "type": "paragraph",
    "text": "42"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 42,
    "type": "paragraph",
    "text": "Création d'instances"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 42,
    "type": "paragraph",
    "text": "➢ Une instance, ou un objet, d'une classe est créée en 3 temps"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 42,
    "type": "code_line",
    "text": "Pixel p1 = new Pixel(1,3);"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 42,
    "type": "diagram_element",
    "text": "➢ new est l'opérateur d'instanciation: comme il est suivi du nom de"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 42,
    "type": "paragraph",
    "text": "la classe, il sait quelle classe doit être instanciée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 42,
    "type": "paragraph",
    "text": "➢ Il initialise chaque champ à sa valeur par défaut"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 42,
    "type": "paragraph",
    "text": "➢ Il peut exécuter un bloc d'initialisation éventuel"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 42,
    "type": "paragraph",
    "text": "➢ Il retournera la référence de l'objet ainsi créé"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 42,
    "type": "paragraph",
    "text": "➢ Pixel est le nom de la classe"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 42,
    "type": "paragraph",
    "text": "➢ (1,3) permet de trouver une fonction d'initialisation particulière"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 42,
    "type": "paragraph",
    "text": "dans la classe, qu'on appelle un constructeur"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 43,
    "type": "paragraph",
    "text": "Etienne DURIS © ESIPE­MLV Université Paris­Est Marne­la­Vallée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 43,
    "type": "paragraph",
    "text": "43"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 43,
    "type": "diagram_element",
    "text": "Constructeur"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 43,
    "type": "paragraph",
    "text": "➢ Un constructeur est une méthode particulière , qui sert à"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 43,
    "type": "paragraph",
    "text": "initialiser un objet une fois que la mémoire est réservée par new"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 43,
    "type": "paragraph",
    "text": "➢ Permet de garantir des invariants sur un objet sont conservés, par"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 43,
    "type": "paragraph",
    "text": "exemple pour initialiser un objet avec des valeurs particulières"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 43,
    "type": "paragraph",
    "text": "➢ Par exemple, on veut qu'un Pixel soit en (1,1)"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 43,
    "type": "paragraph",
    "text": "➢ Le faire avec une méthode « normale » ne garantirait pas qu'on"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 43,
    "type": "paragraph",
    "text": "accède pas à l'état de l'objet avant son initialisation"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 43,
    "type": "paragraph",
    "text": "➢ Le constructeur a le même nom que la classe et pas de type de"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 43,
    "type": "paragraph",
    "text": "retour"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 43,
    "type": "paragraph",
    "text": "➢ En l'absence de"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 43,
    "type": "paragraph",
    "text": "constructeur explicitement défini, le compilateur ajoute un constructeur public"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 43,
    "type": "paragraph",
    "text": "sans paramètre"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 43,
    "type": "code_line",
    "text": "class Box { private int field ; public static void main(String a){ Box b = new Box(); } }"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 44,
    "type": "paragraph",
    "text": "Etienne DURIS © ESIPE­MLV Université Paris­Est Marne­la­Vallée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 44,
    "type": "paragraph",
    "text": "44"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 44,
    "type": "paragraph",
    "text": "Appel à un autre constructeur"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 44,
    "type": "paragraph",
    "text": "➢ Plusieurs constructeurs peuvent cohabiter dans la même classe"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 44,
    "type": "paragraph",
    "text": "➢ Ils ont typiquement des rôles différents et offrent des « services »"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 44,
    "type": "section",
    "text": "complémentaires à l'utilisateur, par exemple:"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 44,
    "type": "paragraph",
    "text": "➢ new Pixel(1,3) crée un pixel avec les coordonnées explicites"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 44,
    "type": "paragraph",
    "text": "➢ new Pixel() crée un pixel avec les coordonnées à l'origine"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 44,
    "type": "code_line",
    "text": "➢ new Pixel(1) crée un pixel sur la diagonale (x == y), etc."
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 44,
    "type": "paragraph",
    "text": "➢ Quand c'est possible, il est"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 44,
    "type": "paragraph",
    "text": "préférable qu'il y en ait un « le plus général » et que les autres y fassent appel"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 44,
    "type": "paragraph",
    "text": "➢ Plutôt que de dupliquer le code"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 44,
    "type": "paragraph",
    "text": "dans plusieurs constrcuteurs"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 44,
    "type": "paragraph",
    "text": "➢ L'appel à un autre constructeur de la"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 44,
    "type": "paragraph",
    "text": "même classe se fait par this(...)"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 44,
    "type": "code_line",
    "text": "public class Pixel { private int x; private int y; public Pixel(int x, int y) { this . x = x; this . y = y; } public Pixel() { this(0,0); } public Pixel(int v) { this (v, v); } }"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 45,
    "type": "paragraph",
    "text": "Etienne DURIS © ESIPE­MLV Université Paris­Est Marne­la­Vallée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 45,
    "type": "paragraph",
    "text": "45"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 45,
    "type": "paragraph",
    "text": "Champ constant"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 45,
    "type": "paragraph",
    "text": "➢ Comme pour les variables locales, il est possible de déclarer un"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 45,
    "type": "paragraph",
    "text": "champ avec le modificateur final ."
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 45,
    "type": "paragraph",
    "text": "➢ Cela signifie qu'il doit avoir"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 45,
    "type": "paragraph",
    "text": "une affectation unique"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 45,
    "type": "paragraph",
    "text": "➢ Le compilateur vérifie que"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 45,
    "type": "paragraph",
    "text": "il a bien été initialisé , et ce quelque soit le constructeur mais également qu'il n'a été affecté qu'une seule fois"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 45,
    "type": "code_line",
    "text": "public class Pixel { private final int x; private int y; public Pixel(int x, int y) { this . x = x; this . y = y; } public Pixel() { // error: final field x may not // have been initialized } public Pixel(int v) { this (v, v); } public static void main(String a){ Pixel p = new Pixel(1); p.x = 0; // error: final field x // cannot been assigned } }"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 46,
    "type": "paragraph",
    "text": "Etienne DURIS © ESIPE­MLV Université Paris­Est Marne­la­Vallée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 46,
    "type": "paragraph",
    "text": "46"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 46,
    "type": "diagram_element",
    "text": "Surcharge"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 46,
    "type": "paragraph",
    "text": "➢ Les méthodes comme les constructeurs peuvent être"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 46,
    "type": "paragraph",
    "text": "surchargées : ( overloaded )"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 46,
    "type": "paragraph",
    "text": "➢ Leur nom est le même"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 46,
    "type": "paragraph",
    "text": "➢ Le nombre ou le type de leurs paramètres varie"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 46,
    "type": "diagram_element",
    "text": "➢ Objectif: fournir plusieurs définitions pour la même méthode"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 46,
    "type": "paragraph",
    "text": "➢ Le compilateur doit pouvoir trouver celui qui convient le mieux"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 46,
    "type": "paragraph",
    "text": "au « site d'appel », c'est à dire au nombre et au type des arguments"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 46,
    "type": "paragraph",
    "text": "➢ Si aucune méthode ne correspond exactement, le compilateur"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 46,
    "type": "paragraph",
    "text": "peut prendre une méthode approchée en fonction du typage"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 47,
    "type": "paragraph",
    "text": "Etienne DURIS © ESIPE­MLV Université Paris­Est Marne­la­Vallée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 47,
    "type": "paragraph",
    "text": "47"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 47,
    "type": "paragraph",
    "text": "Le typage et la surcharge"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 47,
    "type": "paragraph",
    "text": "➢ Les types déclarés des variables pevent quelque fois être"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 47,
    "type": "paragraph",
    "text": "ordonnés par une relation de sous­typage"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 47,
    "type": "paragraph",
    "text": "➢ Il y a du sous­typage sur les types références"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 47,
    "type": "table_row",
    "text": "➢ Lié aux classes, aux interfaces, aux classes abstraites, à l'héritage..."
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 47,
    "type": "paragraph",
    "text": "➢ Sur les types primitifs, on parle de conversion implicite"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 47,
    "type": "paragraph",
    "text": "➢ byte < short < int < long < float < double"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 47,
    "type": "paragraph",
    "text": "char < int"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 47,
    "type": "paragraph",
    "text": "➢ En règle générale, il est préférable d'utiliser la surcharge entre"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 47,
    "type": "paragraph",
    "text": "deux méthodes quand elles ont la même sémantique"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 47,
    "type": "formula",
    "text": "➢ float sqrt(float value) {...} // et"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 47,
    "type": "code_line",
    "text": "double sqrt(double value) {...} // OK"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 47,
    "type": "paragraph",
    "text": "➢ void remove(Object value) {...} // et"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 47,
    "type": "code_line",
    "text": "void remove(int index) {...} // KO (liste)"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 48,
    "type": "paragraph",
    "text": "Etienne DURIS © ESIPE­MLV Université Paris­Est Marne­la­Vallée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 48,
    "type": "paragraph",
    "text": "48"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 48,
    "type": "paragraph",
    "text": "Ambiguité de surcharge"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 48,
    "type": "code_line",
    "text": "public class Overloading { public static void m( int i, long l) { System. out .println( \"m(int, long)\" ); } public static void m( long l, int i) { System. out .println( \"m(long, int)\" ); } public static void main(String args) { int i = 1; long l = 1L; m (i,l); // m(int, long) m (l,i); // m(long, int) m (i,i); // reference to m is ambiguous, // both method m(int,long) and method m(long,int) match } }"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 48,
    "type": "paragraph",
    "text": "➢ Le compilateur peut ne pas savoir laquelle choisir"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 49,
    "type": "paragraph",
    "text": "Etienne DURIS © ESIPE­MLV Université Paris­Est Marne­la­Vallée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 49,
    "type": "paragraph",
    "text": "49"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 49,
    "type": "paragraph",
    "text": "Les membres statiques"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 49,
    "type": "paragraph",
    "text": "➢ Déclarés avec le mot­clé static , les membres statiques sont"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 49,
    "type": "paragraph",
    "text": "liés à la classe et non à une instance particulière (un objet)"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 49,
    "type": "diagram_element",
    "text": "➢ Champs : sa valeur n'est pas propre à un objet mais à la classe"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 49,
    "type": "paragraph",
    "text": "(le champ lui­même, et bien sûr sa valeur, est la même pour tous les objets de la classe)"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 49,
    "type": "paragraph",
    "text": "➢ On y accède à partir du nom de la classe ou de la référence à"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 49,
    "type": "paragraph",
    "text": "n'importe quel objet de la classe"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 49,
    "type": "diagram_element",
    "text": "➢ Méthodes : son code ne dépend pas d'un objet de la classe et"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 49,
    "type": "paragraph",
    "text": "peut être exécuté même si aucun objet existe (e.g. main)"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 49,
    "type": "paragraph",
    "text": "➢ Classes internes"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 49,
    "type": "paragraph",
    "text": "➢ Tout code utilisé dans les membres statiques ne peut pas faire"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 49,
    "type": "paragraph",
    "text": "référence à l'instance courante ( this )"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 50,
    "type": "paragraph",
    "text": "Etienne DURIS © ESIPE­MLV Université Paris­Est Marne­la­Vallée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 50,
    "type": "paragraph",
    "text": "50"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 50,
    "type": "paragraph",
    "text": "Le mystère de println()..."
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 50,
    "type": "code_line",
    "text": "public static void main(String args) {"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 50,
    "type": "paragraph",
    "text": "System. out .println( \"Hi les geeks!\" ); // Hi les geeks!"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 50,
    "type": "paragraph",
    "text": "System. out .println( 'c' ); // c"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 50,
    "type": "paragraph",
    "text": "System. out .println(2.5f); // 2.5"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 50,
    "type": "code_block",
    "text": "Object o = new Object(); System. out .println(o); // java.lang.Object@7a9664a1\nint  tab = new int [5]; System. out .println(tab); // [I@27a8c4e7\nPixel p1 = new Pixel(1,3); System. out .println(p1); // Pixel@20cf2c80 }\nvoid java.io.PrintStream.println(String x)\nvoid java.io.PrintStream.println(char x)\nvoid java.io.PrintStream.println(float x)\nvoid java.io.PrintStream.println(Object x)\nvoid java.io.PrintStream.println(Object x)\nvoid java.io.PrintStream.println(Object x)"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 51,
    "type": "paragraph",
    "text": "Etienne DURIS © ESIPE­MLV Université Paris­Est Marne­la­Vallée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 51,
    "type": "paragraph",
    "text": "51"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 51,
    "type": "paragraph",
    "text": "Comment ça marche?"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 51,
    "type": "section",
    "text": "➢ Les méthodes println() sont surchargées pour être adaptées:"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 51,
    "type": "paragraph",
    "text": "➢ À chaque valeur de type primitif ( boolean char double float int long )"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 51,
    "type": "paragraph",
    "text": "➢ Aux chaînes de caractères ( String et char )"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 51,
    "type": "paragraph",
    "text": "➢ Aux objets ( Object )"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 51,
    "type": "paragraph",
    "text": "➢ Par défaut, toute classe A « hérite » de Object"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 51,
    "type": "diagram_element",
    "text": "➢ Cela induit une relation de sous­typage : A < Object"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 51,
    "type": "paragraph",
    "text": "➢ A définit un « sous­type » de Object"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 51,
    "type": "paragraph",
    "text": "➢ On peut donc appliquer sur A ce qu'on sait faire sur Object"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 51,
    "type": "paragraph",
    "text": "➢ Quand on appelle println() sur un Pixel , ça appelle la méthode"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 51,
    "type": "paragraph",
    "text": "sur Object"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 51,
    "type": "paragraph",
    "text": "➢ Affichage Pixel@20cf2c80 cohérent avec java.lang.Object@7a9664a1"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 52,
    "type": "paragraph",
    "text": "Etienne DURIS © ESIPE­MLV Université Paris­Est Marne­la­Vallée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 52,
    "type": "paragraph",
    "text": "52"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 52,
    "type": "paragraph",
    "text": "Ce que fait la méthode println(Object x)"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 52,
    "type": "paragraph",
    "text": "➢ Si on suit les commentaires de la javadoc (ou le code)"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 52,
    "type": "paragraph",
    "text": "➢ PrintStream.println(Object x) appelle String.valueOf(x)"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 52,
    "type": "paragraph",
    "text": "➢ String.valueOf(Object x) retourne"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 52,
    "type": "paragraph",
    "text": "➢ \"null\" si jamais l'objet x vaut null"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 52,
    "type": "paragraph",
    "text": "➢ x.toString() si x ne vaut pas null"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 52,
    "type": "paragraph",
    "text": "➢ Dans la classe Object , toString() affiche une chaîne construite par"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 52,
    "type": "paragraph",
    "text": "getClass().getName() + '@' + Integer.toHexString(hashCode())"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 52,
    "type": "code_line",
    "text": "➢ Pour notre cas, si Pixel p = new Pixel(1,3);"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 52,
    "type": "paragraph",
    "text": "➢ Comme p est un sous­type de Object , l'appel à println(p) exécute la"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 52,
    "type": "paragraph",
    "text": "méthode println(Object x) sur l'objet p , ce qui appelle String.valueOf(p) qui lui­même retourne p.toString()"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 52,
    "type": "paragraph",
    "text": "➢ Comme il n'y a pas de méthode toString() explicitement définie dans"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 52,
    "type": "paragraph",
    "text": "Pixel , c'est la méthode toString() de Object « héritée » dans Pixel qui est appelée. CQFD."
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 53,
    "type": "paragraph",
    "text": "Etienne DURIS © ESIPE­MLV Université Paris­Est Marne­la­Vallée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 53,
    "type": "paragraph",
    "text": "53"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 53,
    "type": "paragraph",
    "text": "Là où c'est fort..."
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 53,
    "type": "paragraph",
    "text": "➢ Quand une méthode m() est appelée sur une variable v qui"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 53,
    "type": "paragraph",
    "text": "contient une référence"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 53,
    "type": "paragraph",
    "text": "➢ Le compilateur vérifie qu'il y a bien une méthode m() définie pour"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 53,
    "type": "paragraph",
    "text": "le type déclaré de la variable v (« au pire, je sais faire »)"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 53,
    "type": "paragraph",
    "text": "➢ La JVM (à l'exécution) recherche une définition pour cette"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 53,
    "type": "paragraph",
    "text": "méthode m() qui soit la plus précise possible ,i.e., la plus proche du type « réel » de la référence contenue dans v"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 53,
    "type": "code_line",
    "text": "➢ Par exemple, si Object v = new Pixel(1,3);"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 53,
    "type": "paragraph",
    "text": "➢ C'est possible car Pixel est un sous­type de Object"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 53,
    "type": "paragraph",
    "text": "➢ v est déclarée de type Object ( info compile time ), mais contient en"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 53,
    "type": "paragraph",
    "text": "réalité une référence à un objet de type Pixel ( info run time )"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 53,
    "type": "paragraph",
    "text": "➢ Si m() est la méthode toString() , le compilateur dit « banco » pour"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 53,
    "type": "code_line",
    "text": "Object.toString() et la JVM recherche Pixel.toString()"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 53,
    "type": "paragraph",
    "text": "➢ Si Pixel.toString() n'existe pas, celle de Object qui est « héritée »"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 54,
    "type": "paragraph",
    "text": "Etienne DURIS © ESIPE­MLV Université Paris­Est Marne­la­Vallée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 54,
    "type": "paragraph",
    "text": "54"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 54,
    "type": "paragraph",
    "text": "Et voilà le travail..."
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 54,
    "type": "paragraph",
    "text": "➢ Il « suffit » alors de donner sa propre définition de toString()"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 54,
    "type": "paragraph",
    "text": "dans la classe Pixel"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 54,
    "type": "paragraph",
    "text": "➢ On dit qu'on « redéfinit » ( Override ) la méthode toString()"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 54,
    "type": "code_block",
    "text": "public class Pixel { // ... @Override public String toString() { return \"(\" + x + \",\" + y + \")\" ; } public static void main(String args) { Object o = new Pixel(1,3); System. out .println(o); // (1,3)\n// et a fortiori Pixel p = new Pixel(5,7); System. out .println(p); // (5,7) } } void java.io.PrintStream.println(Object x)"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 54,
    "type": "paragraph",
    "text": "L'annotation @Override demande au compilateur de vérifier qu'on est bien en train"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 54,
    "type": "paragraph",
    "text": "de redéfinir une méthode qui"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 54,
    "type": "paragraph",
    "text": "sinon serait héritée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 54,
    "type": "code_line",
    "text": "void java.io.PrintStream.println(Object x)"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 55,
    "type": "paragraph",
    "text": "Etienne DURIS © ESIPE­MLV Université Paris­Est Marne­la­Vallée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 55,
    "type": "paragraph",
    "text": "55"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 55,
    "type": "paragraph",
    "text": "Le sous­typage"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 55,
    "type": "section",
    "text": "➢ L'idée (de la redéfinition de toString()) est que:"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 55,
    "type": "paragraph",
    "text": "➢ Le comportement dépend de l'objet réellement contenu dans la"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 55,
    "type": "paragraph",
    "text": "variable"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 55,
    "type": "paragraph",
    "text": "➢ L'affichage d'un objet est différent de l'affichage d'un Pixel"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 55,
    "type": "paragraph",
    "text": "➢ Mais les deux peuvent s'afficher..."
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 55,
    "type": "paragraph",
    "text": "➢ Ils disposent tous les deux de la « méthode » toString()"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 55,
    "type": "paragraph",
    "text": "➢ Plus généralement, on voudrait avoir des types"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 55,
    "type": "paragraph",
    "text": "➢ Sur lesquels un ensemble de méthodes est disponible"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 55,
    "type": "paragraph",
    "text": "➢ Mais dont la définition exacte dépend du sous­type"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 55,
    "type": "paragraph",
    "text": "➢ La méthode finalement exécutée sera la plus précise possible"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 55,
    "type": "diagram_element",
    "text": "➢ Exemple: toute figure a une surface, mais la surface d'un carré"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 55,
    "type": "paragraph",
    "text": "ne se calcule pas comme la surface d'un cercle..."
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 56,
    "type": "paragraph",
    "text": "Etienne DURIS © ESIPE­MLV Université Paris­Est Marne­la­Vallée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 56,
    "type": "paragraph",
    "text": "56"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 56,
    "type": "paragraph",
    "text": "Comment définir des sous­types"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 56,
    "type": "paragraph",
    "text": "➢ On a vu les relations de conversions qui sont autorisées entre"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 56,
    "type": "paragraph",
    "text": "types primitifs"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 56,
    "type": "paragraph",
    "text": "➢ byte < short < int < long < float < double"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 56,
    "type": "paragraph",
    "text": "char < int"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 56,
    "type": "paragraph",
    "text": "➢ On a vu que toute classe A hérite de la classe Object , et définit"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 56,
    "type": "paragraph",
    "text": "ainsi un type A qui est sous­type du type Object"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 56,
    "type": "section",
    "text": "➢ L' héritage définit des sous­types:"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 56,
    "type": "code_line",
    "text": "➢ Soit explicitement: class Student extends Person { ... }"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 56,
    "type": "paragraph",
    "text": "➢ Soit implicitement Pixel ou int héritent de Object"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 56,
    "type": "paragraph",
    "text": "➢ L' implémentation d'interface définit des sous­types"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 56,
    "type": "paragraph",
    "text": "➢ Une interface déclare les méthodes applicables par les objets des"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 56,
    "type": "paragraph",
    "text": "classes qui l'implémentent"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 56,
    "type": "section",
    "text": "➢ Une classe implémente l'interface en définissant ses méthodes :"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 56,
    "type": "code_line",
    "text": "class Carre implements Mesurable { ... }"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 57,
    "type": "paragraph",
    "text": "Etienne DURIS © ESIPE­MLV Université Paris­Est Marne­la­Vallée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 57,
    "type": "paragraph",
    "text": "57"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 57,
    "type": "paragraph",
    "text": "L'héritage"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 57,
    "type": "paragraph",
    "text": "➢ Consiste à définir une classe , dite classe dérivée ou classe fille ,"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 57,
    "type": "paragraph",
    "text": "à partir d'une autre classe , dite classe de base ou classe mère , en récupérant automatiquement dans la classe dérivée tous les membres de la classe de base, et en lui en ajoutant éventuellement de nouveaux membres"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 57,
    "type": "code_block",
    "text": "public class Pixel {\nprivate int x ; private int y ; public void moveTo( int newX, int newY) {\nthis . x = newX; this . y = newY; } }\npublic class ColoredPixel extends Pixel {\nprivate byte  rgb ; public byte getRed() { return rgb [0]; } public byte getGreen() { return rgb [1]; } public byte getBlue() { return rgb [2]; } }"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 57,
    "type": "diagram",
    "text": "Pixel\nx:int\ny:int"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 57,
    "type": "paragraph",
    "text": "moveTo(int,int)"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 57,
    "type": "diagram",
    "text": "ColoredPixel\nrgb:byte"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 57,
    "type": "code_block",
    "text": "getRed():byte\ngetGreen():byte\ngetBlue():byte"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 58,
    "type": "paragraph",
    "text": "Etienne DURIS © ESIPE­MLV Université Paris­Est Marne­la­Vallée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 58,
    "type": "paragraph",
    "text": "58"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 58,
    "type": "paragraph",
    "text": "Que sont les objets de la classe dérivée?"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 58,
    "type": "paragraph",
    "text": "➢ Tout objet d'une classe dérivée est considéré comme étant"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 58,
    "type": "paragraph",
    "text": "avant tout un objet de la classe de base"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 58,
    "type": "paragraph",
    "text": "➢ Un pixel coloré est avant tout un pixel"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 58,
    "type": "paragraph",
    "text": "➢ Tout objet d'une classe dérivée « cumule » les champs dérivés"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 58,
    "type": "paragraph",
    "text": "dans la classe de base avec ceux définis dans sa propre classe"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 58,
    "type": "paragraph",
    "text": "➢ Il y a un int x et un int y dans un objet de la classe ColoredPixel"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 58,
    "type": "code_block",
    "text": "public static void main(String args) {\nPixel p = new Pixel(); p.moveTo(1, 1);\nColoredPixel cp = new ColoredPixel(); cp.moveTo(2, 2);\ncp.getRed(); // NullPointerException }\n#1 #1\n#2\n@class Pixel\n#2"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 58,
    "type": "diagram",
    "text": "x : 1\ny : 1"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 58,
    "type": "code_line",
    "text": "@class ColoredPixel"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 58,
    "type": "diagram",
    "text": "x : 2\ny : 2\nrgb : null"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 59,
    "type": "paragraph",
    "text": "Etienne DURIS © ESIPE­MLV Université Paris­Est Marne­la­Vallée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 59,
    "type": "paragraph",
    "text": "59"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 59,
    "type": "paragraph",
    "text": "Tous les champs sont hérités"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 59,
    "type": "paragraph",
    "text": "➢ Ils peuvent être manipulés si leur accessibilité le permet"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 59,
    "type": "code_line",
    "text": "➢ Si x n'est pas private dans Pixel , on peut dire this.x dans"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 59,
    "type": "diagram_element",
    "text": "ColoredPixel"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 59,
    "type": "paragraph",
    "text": "➢ Ils peuvent être masqués par la définition de champs qui ont le"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 59,
    "type": "paragraph",
    "text": "même nom dans la classe dérivée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 59,
    "type": "paragraph",
    "text": "➢ Si String x est déclaré dans ColoredPixel , c'est celui qui sera"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 59,
    "type": "code_line",
    "text": "considéré dans cette classe quand on parle de this.x"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 59,
    "type": "paragraph",
    "text": "➢ Il est possible de manipuler celui qui est masqué (s'il est accessible)"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 59,
    "type": "paragraph",
    "text": "par la notation super.x"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 59,
    "type": "code_block",
    "text": "public class Pixel {\nint x ; private int y ; // ... }\npublic class ColoredPixel extends Pixel {\nprivate byte  rgb ; String x; void test() {\nSystem. out .println( this . x ); // null System. out .println( super . x ); // 0 } }"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 60,
    "type": "paragraph",
    "text": "Etienne DURIS © ESIPE­MLV Université Paris­Est Marne­la­Vallée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 60,
    "type": "paragraph",
    "text": "60"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 60,
    "type": "paragraph",
    "text": "Résolution du champ à accéder"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 60,
    "type": "paragraph",
    "text": "➢ La détermination du champ qui doit être accédé s'appelle"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 60,
    "type": "paragraph",
    "text": "« la résolution »"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 60,
    "type": "paragraph",
    "text": "➢ il s'agit de savoir où on ira chercher la valeur à l'exécution"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 60,
    "type": "paragraph",
    "text": "➢ La résolution des champs est effectuée par le compilateur, en"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 60,
    "type": "paragraph",
    "text": "fonction du type déclaré de la variable qui contient la référence"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 60,
    "type": "code_block",
    "text": "public static void main(String args) {\nColoredPixel cp = new ColoredPixel(); // le type déclaré de cp est ColoredPixel"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 60,
    "type": "paragraph",
    "text": "System. out .println(cp. x ); // null"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 60,
    "type": "code_block",
    "text": "Pixel p = cp; // le type déclaré de p est Pixel, même si la référence // contenue dans p est celle d'un ColoredPixel\nSystem. out .println(p. x ); // 0 }"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 61,
    "type": "paragraph",
    "text": "Etienne DURIS © ESIPE­MLV Université Paris­Est Marne­la­Vallée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 61,
    "type": "paragraph",
    "text": "61"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 61,
    "type": "paragraph",
    "text": "Le masquage des champs"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 61,
    "type": "paragraph",
    "text": "➢ Si c'est possible de créer dans une classe héritée un champ qui"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 61,
    "type": "paragraph",
    "text": "a le même nom qu'un champs d'une superclasse"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 61,
    "type": "paragraph",
    "text": "➢ C'est rarement très utile, souvent une mauvaise idée, source"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 61,
    "type": "paragraph",
    "text": "d'erreur"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 61,
    "type": "paragraph",
    "text": "➢ super , c'est this vu avec"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 61,
    "type": "paragraph",
    "text": "le type de la super­classe"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 61,
    "type": "paragraph",
    "text": "➢ super.super.x n'existe pas..."
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 61,
    "type": "paragraph",
    "text": "➢ Pas plus que ref.super"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 61,
    "type": "paragraph",
    "text": "ni ref.super.x ..."
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 61,
    "type": "paragraph",
    "text": "➢ En revanche, le transtypage ( cast ) permet d'accéder en changeant le type déclaré"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 61,
    "type": "paragraph",
    "text": "de la référence ref"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 61,
    "type": "code_block",
    "text": "class A { int x = 1; }\nclass B extends A { String x = \"zz\" ; }\nclass C extends B { boolean x = true ; public static void main(String args) { C c = new C(); System. out .println(c. x ); // true System. out .println(((B)c). x ); // zz System. out .println(((A)c). x ); // 1 } }"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 62,
    "type": "paragraph",
    "text": "Etienne DURIS © ESIPE­MLV Université Paris­Est Marne­la­Vallée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 62,
    "type": "paragraph",
    "text": "62"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 62,
    "type": "paragraph",
    "text": "Transtypage, type déclaré et type « réel »"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 62,
    "type": "paragraph",
    "text": "➢ Le transtypage de référence est le fait de considérer"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 62,
    "type": "paragraph",
    "text": "explicitement (forcer) une référence comme étant d'un type donné (qui n'est pas nécessairement le type de l'objet accessible via cette référence)"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 62,
    "type": "paragraph",
    "text": "➢ La machine virtuelle vérifiera, à l'exécution, que le type en"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 62,
    "type": "paragraph",
    "text": "question est bien compatible et que voir cette référence comme étant de ce type là est possible; dans le cas contraire, l'exécution provoque une ClassCastException"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 62,
    "type": "code_block",
    "text": "B b = new B(); A a = b; // B b2 = a; // incompatible types B b2 = (B) a; // OK C c = (C) a; // ClassCastException\nclass A { } class B extends A { } class C extends B { }\nObject o; if (Math.random() > 0.5) o = \"toto\"; else o = new Object(); String s = (String) o; // Compile toujours mais a une // chance sur deux de lever une // ClassCastException..."
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 63,
    "type": "paragraph",
    "text": "Etienne DURIS © ESIPE­MLV Université Paris­Est Marne­la­Vallée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 63,
    "type": "paragraph",
    "text": "63"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 63,
    "type": "paragraph",
    "text": "L'opérateur instanceof"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 63,
    "type": "paragraph",
    "text": "➢ Il est possible d'assurer un transtypage sans exception en"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 63,
    "type": "paragraph",
    "text": "utilisant l'opérateur x instanceof T"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 63,
    "type": "paragraph",
    "text": "➢ x doit être une (variable contenant une) référence ou null"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 63,
    "type": "paragraph",
    "text": "➢ T doit rerpésenter un type"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 63,
    "type": "paragraph",
    "text": "➢ Le résultat vaut true si x n'est pas null et s'il peut être affecté dans"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 63,
    "type": "paragraph",
    "text": "T sans ClassCastException ; sinon c'est false ."
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 63,
    "type": "code_block",
    "text": "A ab = null ; System. out .println(ab instanceof A); // false ab = new B(); System. out .println(ab instanceof A); // true System. out .println(ab instanceof B); // true System. out .println(ab instanceof C); // false\nclass A { } class B extends A { } class C extends B { } Object o; String s; if (Math. random ()>0.5) o = \"toto\" ; else o = new Object(); if (o instanceof String) s = (String) o; // OK..."
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 64,
    "type": "paragraph",
    "text": "Etienne DURIS © ESIPE­MLV Université Paris­Est Marne­la­Vallée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 64,
    "type": "paragraph",
    "text": "64"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 64,
    "type": "paragraph",
    "text": "Constructeurs et héritage"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 64,
    "type": "paragraph",
    "text": "➢ La construction (initialisation) de toute instance d'une classe"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 64,
    "type": "paragraph",
    "text": "débute par la construction (initialisation) d'une instance d'Object"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 64,
    "type": "paragraph",
    "text": "➢ En pratique, tout constructeur débute par un appel au"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 64,
    "type": "diagram_element",
    "text": "constructeur de sa super­classe: super()"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 64,
    "type": "paragraph",
    "text": "➢ Doit obligatoirement être la première instruction du constructeur"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 64,
    "type": "paragraph",
    "text": "➢ Le constructeur implicite (ajouté par le compilateur) fait appel au"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 64,
    "type": "code_block",
    "text": "constructeur sans argument de la super­classe public class Pixel {\nprivate int x ; private int y ; public Pixel( int x, int y) {\nthis . x = newX; this . y = newY; } // ... }\npublic class ColoredPixel extends Pixel { private byte  rgb ; public ColoredPixel() { // super (); // Constructeur Pixel() is undefined super (0,0); // OK; notez que x et y sont private! rgb = new byte [3]; } }"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 65,
    "type": "paragraph",
    "text": "Etienne DURIS © ESIPE­MLV Université Paris­Est Marne­la­Vallée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 65,
    "type": "paragraph",
    "text": "65"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 65,
    "type": "paragraph",
    "text": "Constructeurs et initialisations"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 65,
    "type": "paragraph",
    "text": "➢ Il faut voir le constructeur d'une classe comme une étape dans"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 65,
    "type": "section",
    "text": "l'initialisation des objets de cette classe:"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 65,
    "type": "paragraph",
    "text": "➢ Commence par l'initialisation des champs de l'objet « en tant"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 65,
    "type": "paragraph",
    "text": "qu'instance de la super­classe »: c'est l'objectif de l'appel à super(...)"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 65,
    "type": "paragraph",
    "text": "➢ Ensuite il se charge d'initialiser les objets qui lui sont propres (en tant"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 65,
    "type": "paragraph",
    "text": "qu'instance de la classe dérivée)"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 65,
    "type": "paragraph",
    "text": "➢ L'appel à super ne peut pas utiliser des champs dont l'existence ou la"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 65,
    "type": "paragraph",
    "text": "valeur dépendrait de l'instance de la classe dérivée..."
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 65,
    "type": "code_line",
    "text": "public class ColoredPixel extends Pixel { private int v = 0; private static int s = 0; public ColoredPixel() { // super(v,v); // error: cannot reference v before supertype constructor has been called super ( s , s ); // OK } }"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 66,
    "type": "paragraph",
    "text": "Etienne DURIS © ESIPE­MLV Université Paris­Est Marne­la­Vallée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 66,
    "type": "paragraph",
    "text": "66"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 66,
    "type": "paragraph",
    "text": "L'héritage des méthodes"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 66,
    "type": "paragraph",
    "text": "➢ En plus des champs, en tant que « membres », la classe"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 66,
    "type": "paragraph",
    "text": "dérivée hérite des méthodes de la classe de base"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 66,
    "type": "paragraph",
    "text": "➢ Seuls les constructeurs ne sont pas hérités"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 66,
    "type": "paragraph",
    "text": "➢ Ils restent propres à leur classe"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 66,
    "type": "diagram_element",
    "text": "➢ Attention: le code (sémantique) d'une méthode de la super"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 66,
    "type": "paragraph",
    "text": "classe peut ne plus être correct dans la classe dérivée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 66,
    "type": "section",
    "text": "➢ Pour l'exemple de Pixel et ColoredPixel:"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 66,
    "type": "paragraph",
    "text": "➢ moveTo() héritée dans ColoredPixel a une sémantique correcte"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 66,
    "type": "paragraph",
    "text": "➢ Mais que dire de toString() qui donne une représentation textuelle?"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 66,
    "type": "paragraph",
    "text": "➢ Que dire de sameAs() qui compare un pixel à un autre pixel?"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 66,
    "type": "paragraph",
    "text": "➢ Dans certains cas, il faut donner une nouvelle définition de la"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 66,
    "type": "paragraph",
    "text": "même méthode à utiliser pour la classe dérivée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 67,
    "type": "paragraph",
    "text": "Etienne DURIS © ESIPE­MLV Université Paris­Est Marne­la­Vallée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 67,
    "type": "paragraph",
    "text": "67"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 67,
    "type": "paragraph",
    "text": "Redéfinition de méthode"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 67,
    "type": "section",
    "text": "➢ Fournir une nouvelle définition pour la même méthode:"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 67,
    "type": "paragraph",
    "text": "➢ Même nom, mêmes arguments, code différent"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 67,
    "type": "paragraph",
    "text": "➢ L'annotation @Override demande au compilateur de vérifier"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 67,
    "type": "code_line",
    "text": "public class ColoredPixel extends Pixel { private byte  rgb ; // ... @Override public String toString() { return super .toString()+ \"[\" + rgb [0]+ \":\" + rgb [1]+ \":\" + rgb [2]+ \"]\" ; } public static void main(String args) { ColoredPixel cp = new ColoredPixel(2,2); System. out .println(cp); // (2,2)[0:0:0] Pixel p = new Pixel(5,5); System. out .println(p); // (5,5) Object o = new ColoredPixel(2,2); System. out .println(o); // (2,2)[0:0:0] } }"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 68,
    "type": "paragraph",
    "text": "Etienne DURIS © ESIPE­MLV Université Paris­Est Marne­la­Vallée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 68,
    "type": "paragraph",
    "text": "68"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 68,
    "type": "paragraph",
    "text": "Redéfinition (méthodes) versus masquage (champs)"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 68,
    "type": "paragraph",
    "text": "➢ Les champs définis dans les classes dérivées sont tous"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 68,
    "type": "paragraph",
    "text": "présents dans l'objet instance de la classe dérivée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 68,
    "type": "paragraph",
    "text": "➢ Même s'ils ont même nom et même type"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 68,
    "type": "paragraph",
    "text": "➢ On peut accéder à celui immédiatement supérieur par super.x"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 68,
    "type": "paragraph",
    "text": "➢ La résolution dépend du type déclaré du paramètre"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 68,
    "type": "paragraph",
    "text": "➢ Ça permet d'accéder à chacun d'entre eux par transtypage"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 68,
    "type": "paragraph",
    "text": "➢ Pour la méthode , une seule est conservée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 68,
    "type": "paragraph",
    "text": "➢ On peut accéder à celle immédiatement supérieure par super.m()"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 68,
    "type": "paragraph",
    "text": "➢ La résolution est faite en deux temps"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 68,
    "type": "diagram",
    "text": "➢ Compile­time : on vérifie que c'est possible sur le type déclaré\n➢ Runtime : on cherche la plus précise étant donnée le type « réel »"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 68,
    "type": "paragraph",
    "text": "➢ Les autres ne sont plus accessibles"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 69,
    "type": "paragraph",
    "text": "Etienne DURIS © ESIPE­MLV Université Paris­Est Marne­la­Vallée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 69,
    "type": "paragraph",
    "text": "69"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 69,
    "type": "paragraph",
    "text": "Redéfinition versus surcharge"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 69,
    "type": "paragraph",
    "text": "➢ Si la signature de la méthode qu'on définit dans la classe"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 69,
    "type": "section",
    "text": "dérivée n'est pas le même que celle de la classe de base, il s'agit de surcharge :"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 69,
    "type": "paragraph",
    "text": "➢ Les deux méthodes cohabitent dans la classe dérivée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 69,
    "type": "code_line",
    "text": "class A { void m1() { ... } void m2() { ... } Pixel m3() { ... } void m4(Pixel p) { ... } } class B extends A { @Override void m1() { ... } // redefinition void m2( int a) { ... } // surcharge @Override ColoredPixel m3() { ... } // redefinition @Override void m4(Pixel p) { ... } // redefinition void m4(ColoredPixel p) { ... } // surcharge }"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 70,
    "type": "paragraph",
    "text": "Etienne DURIS © ESIPE­MLV Université Paris­Est Marne­la­Vallée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 70,
    "type": "paragraph",
    "text": "70"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 70,
    "type": "paragraph",
    "text": "Les principes de la redéfinition"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 70,
    "type": "paragraph",
    "text": "➢ Quand on redéfinit une méthode m() dans B alors qu'elle était"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 70,
    "type": "paragraph",
    "text": "définie dans A , où B est un sous­type de A"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 70,
    "type": "paragraph",
    "text": "➢ L'objectif est de lui donner une définition plus précise (mieux adaptée à"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 70,
    "type": "paragraph",
    "text": "B qu'à A) , de sorte qu'elle soit appelée à run­time , y compris si à compile­time le compilateur n'avait vu que celle qui est définie dans A"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 70,
    "type": "paragraph",
    "text": "➢ Le compilateur est sensé éviter les mauvaises surprises (découvrir"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 70,
    "type": "paragraph",
    "text": "un problème à run­time): c'est ce qui gouverne les règles"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 70,
    "type": "paragraph",
    "text": "➢ Une méthode d'instance ne peut pas redéfinir une méthode static"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 70,
    "type": "paragraph",
    "text": "➢ L'accessibilité de la méthode redéfinie ne peut pas être plus restrictive"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 70,
    "type": "paragraph",
    "text": "➢ Le type de retour ne peut pas être d'un super­type (références)"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 70,
    "type": "paragraph",
    "text": "➢ Les exceptions propagées ne peuvent être que d'un sous­type"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 71,
    "type": "paragraph",
    "text": "Etienne DURIS © ESIPE­MLV Université Paris­Est Marne­la­Vallée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 71,
    "type": "paragraph",
    "text": "71"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 71,
    "type": "paragraph",
    "text": "Le cas de sameAs..."
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 71,
    "type": "paragraph",
    "text": "➢ On a redéfinit la méthode toString()"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 71,
    "type": "paragraph",
    "text": "➢ Donner une représentation textuelle plus précise dans"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 71,
    "type": "diagram_element",
    "text": "ColoredPixel : c'est facile (même signature)"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 71,
    "type": "paragraph",
    "text": "➢ On voudrait aussi redéfinir sameAs()"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 71,
    "type": "paragraph",
    "text": "➢ Actuellement, la méthode héritée est fausse!"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 71,
    "type": "diagram_element",
    "text": "➢ Redéfinition: pas si simple avec la signature de sameAs()"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 71,
    "type": "code_block",
    "text": "// public boolean sameAs(ColoredPixel p) { // Surcharge et pas redéfinition\n@Override public boolean sameAs(Pixel p) { // return ( x ==p. x ) && ( y ==p. y ) & p.rgb[0]=rgb[0] ... // Aïe! x and y: private access in Pixel // return super .sameAs(p) && p.rgb[0]=rgb[0] ... // Aïe! rgb is not a field // return super .sameAs(p) && ((ColoredPixel)p). rgb [0]== rgb [0] ... // Compile, mais si p n'en est pas un ColoredPixel... Aïe! // Il faut utiliser instanceof... }"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 72,
    "type": "paragraph",
    "text": "Etienne DURIS © ESIPE­MLV Université Paris­Est Marne­la­Vallée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 72,
    "type": "paragraph",
    "text": "72"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 72,
    "type": "paragraph",
    "text": "La méthode equals()"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 72,
    "type": "paragraph",
    "text": "➢ De la même manière qu'il existe une méthode toString() dans la"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 72,
    "type": "paragraph",
    "text": "classe Object , que toute sous­classe peut redéfinir"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 72,
    "type": "paragraph",
    "text": "➢ Il existe dans Object une méthode equals(Object obj) dont le"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 72,
    "type": "paragraph",
    "text": "« contrat » est clairement établi par la documentation"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 72,
    "type": "paragraph",
    "text": "➢ Par défaut, elle teste l' égalité primitive des références (même objet)"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 72,
    "type": "paragraph",
    "text": "➢ C'est celle­là qu'il faut redéfinir!"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 72,
    "type": "code_block",
    "text": "public class Pixel { private int x, y ; // ... @Override public boolean equals(Object obj) { if (!(obj instanceof Pixel)) return false ; Pixel p = (Pixel) obj; return ( x ==p. x ) && ( y ==p. y ); } }\npublic class ColoredPixel extends Pixel { private byte  rgb ; @Override public boolean equals(Object obj) { if (!(obj instanceof ColoredPixel)) return false ; ColoredPixel cp = (ColoredPixel) obj; return super . equals(obj) && rgb [0]==cp. rgb [0] && rgb [1]==cp. rgb [1] && rgb [2]==cp. rgb [2]; } }"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 73,
    "type": "paragraph",
    "text": "Etienne DURIS © ESIPE­MLV Université Paris­Est Marne­la­Vallée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 73,
    "type": "paragraph",
    "text": "73"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 73,
    "type": "paragraph",
    "text": "Le contrat de la méthode equals()"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 73,
    "type": "paragraph",
    "text": "➢ Définit une relation d'équivalence sur les références non­nulles"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 73,
    "type": "paragraph",
    "text": "➢ Reflexive"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 73,
    "type": "paragraph",
    "text": "➢ Pour toute référence x non nulle, x.equals(x) vaut true"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 73,
    "type": "paragraph",
    "text": "➢ Symétrique"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 73,
    "type": "paragraph",
    "text": "➢ Pour toutes références x et y non nulles, x.equals(y) ssi y.equals(x)"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 73,
    "type": "paragraph",
    "text": "➢ Transitive"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 73,
    "type": "paragraph",
    "text": "➢ Pour toutes références x, y et z non nulles,"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 73,
    "type": "paragraph",
    "text": "si x.equals(y) et y.equals(z) alors x.equals(z )"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 73,
    "type": "paragraph",
    "text": "➢ Cohérente"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 73,
    "type": "paragraph",
    "text": "➢ Tant qu'on ne modifie pas les valeurs utilisées pour tester l'égalité, la valeur de"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 73,
    "type": "code_line",
    "text": "x.equals(y) retourne toujours la même valeur"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 73,
    "type": "paragraph",
    "text": "➢ Pour toute référence x non nulle, x.equals(null) vaut false"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 73,
    "type": "paragraph",
    "text": "➢ Des objets égaux au sens de equals doivent avoir le même hashcode"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 73,
    "type": "paragraph",
    "text": "➢ Redéfinition de equals() implique en général redéfinition de hashCode()"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 73,
    "type": "paragraph",
    "text": "Bof bof... dans notre cas de"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 73,
    "type": "paragraph",
    "text": "ColoredPixel, c'est limite..."
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 74,
    "type": "paragraph",
    "text": "Etienne DURIS © ESIPE­MLV Université Paris­Est Marne­la­Vallée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 74,
    "type": "paragraph",
    "text": "74"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 74,
    "type": "paragraph",
    "text": "La symétrie peut se discuter..."
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 74,
    "type": "paragraph",
    "text": "➢ Demandez à un Pixel en (2,2) s'il est égal à un ColoredPixe l en"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 74,
    "type": "paragraph",
    "text": "(2,2), il dira que oui!"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 74,
    "type": "paragraph",
    "text": "➢ Il teste uniquement les coordonnées..."
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 74,
    "type": "paragraph",
    "text": "➢ Demandez à un ColoredPixel magenta en (2,2) s'il est égal à un"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 74,
    "type": "code_line",
    "text": "Pixel en (2,2), il dira que non!"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 74,
    "type": "paragraph",
    "text": "➢ Il est sensé tester la couleur que le Pixel n'a même pas..."
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 74,
    "type": "paragraph",
    "text": "➢ On peut trouver que ce code est acceptable... il faut juste être"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 74,
    "type": "paragraph",
    "text": "conscient de la nuance..."
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 74,
    "type": "code_line",
    "text": "public class ColoredPixel extends Pixel { // ... public static void main(String args) { Object o1 = new Pixel(2,2); Object o2 = new ColoredPixel(2,2); System. out .println(o1.equals(o2)); // true System. out .println(o2.equals(o1)); // false } }"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 75,
    "type": "paragraph",
    "text": "Etienne DURIS © ESIPE­MLV Université Paris­Est Marne­la­Vallée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 75,
    "type": "paragraph",
    "text": "75"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 75,
    "type": "paragraph",
    "text": "Pour être plus strict..."
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 75,
    "type": "paragraph",
    "text": "➢ Il faut considérer que deux objets qui ne sont pas de la même"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 75,
    "type": "paragraph",
    "text": "classe ne peuvent pas être égaux"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 75,
    "type": "paragraph",
    "text": "➢ instanceof ne suffit plus"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 75,
    "type": "paragraph",
    "text": "➢ Il faut connaître la classe"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 75,
    "type": "paragraph",
    "text": "« exacte » de l'objet (à runtime)"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 75,
    "type": "paragraph",
    "text": "➢ Méthode Class getClass()"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 75,
    "type": "paragraph",
    "text": "de la classe Object"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 75,
    "type": "code_block",
    "text": "public static void main(String args) { Object o1 = new Pixel(2,2); Object o2 = new ColoredPixel(2,2); System. out .println(o1.equals(o2)); // false System. out .println(o2.equals(o1)); // false }\n@Override public boolean equals(Object obj) { if (obj.getClass() != Pixel. class ) return false ; Pixel p = (Pixel) obj; return ( x ==p. x ) && ( y ==p. y ); }\n@Override public boolean equals(Object obj) { if (obj.getClass() != ColoredPixel. class ) return false ; ColoredPixel cp = (ColoredPixel) obj; return super .equals(obj) && Arrays. equals ( this . rgb , cp. rgb ); }"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 75,
    "type": "section",
    "text": "Dans Pixel :"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 75,
    "type": "section",
    "text": "Dans ColoredPixel :"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 76,
    "type": "paragraph",
    "text": "Etienne DURIS © ESIPE­MLV Université Paris­Est Marne­la­Vallée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 76,
    "type": "paragraph",
    "text": "76"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 76,
    "type": "paragraph",
    "text": "La méthode hashCode()"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 76,
    "type": "paragraph",
    "text": "➢ Cette méthode est utlisée lorsqu'on stocke des objets dans une"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 76,
    "type": "paragraph",
    "text": "table de hachage (exemple java.util.HashMap )"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 76,
    "type": "paragraph",
    "text": "➢ Elle établit également un « contrat » (de pair avec equals() )"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 76,
    "type": "paragraph",
    "text": "➢ public int hashCode()"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 76,
    "type": "paragraph",
    "text": "➢ Étant donnée une exécution de la JVM, différents appels à la"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 76,
    "type": "paragraph",
    "text": "méthode hashCode() doivent retourner la même valeur tant qu'on ne modifie pas les valeurs utilisées pour tester l'égalité ( equals() )"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 76,
    "type": "paragraph",
    "text": "➢ Si deux objets sont égaux au sens de equals() , la méthode"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 76,
    "type": "paragraph",
    "text": "hashCode() appelée sur les deux doit produire la même valeur"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 76,
    "type": "paragraph",
    "text": "➢ Deux objets distincts au sens de equals() peuvent avoir des"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 76,
    "type": "paragraph",
    "text": "hashCode() identiques (c'est une « collision »), mais fournir des hashCode() distincts pour des objets distincts au sens de equals() améliore la performance des tables de hachage."
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 77,
    "type": "paragraph",
    "text": "Etienne DURIS © ESIPE­MLV Université Paris­Est Marne­la­Vallée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 77,
    "type": "paragraph",
    "text": "77"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 77,
    "type": "paragraph",
    "text": "Utilisation de hashCode() et equals()"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 77,
    "type": "paragraph",
    "text": "➢ Les ensembles, les tables de hachage, etc."
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 77,
    "type": "paragraph",
    "text": "➢ Si equals est redéfinie, mais pas hashCode, voilà ce qui arrive"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 77,
    "type": "code_block",
    "text": "import java.util.HashSet;\npublic class Pixel { // ... public static void main(String args) { Pixel zero = new Pixel(0,0); Pixel def = new Pixel();\nHashSet set = new HashSet(); set.add(zero);"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 77,
    "type": "paragraph",
    "text": "System. out .println(set.contains(def)); // false"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 77,
    "type": "paragraph",
    "text": "System. out .println(zero.hashCode()); // 1522065175 System. out .println(def.hashCode()); // 524193161"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 77,
    "type": "code_line",
    "text": "System. out .println(zero.equals(def)); // true } }"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 77,
    "type": "paragraph",
    "text": "Incohérence entre equals() et hashCode()"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 78,
    "type": "paragraph",
    "text": "Etienne DURIS © ESIPE­MLV Université Paris­Est Marne­la­Vallée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 78,
    "type": "paragraph",
    "text": "78"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 78,
    "type": "paragraph",
    "text": "Exemple de hashCode() pour nos pixels"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 78,
    "type": "code_block",
    "text": "public class ColoredPixel extends Pixel { private byte  rgb ; // ... @Override public int hashCode() { // return super.hashCode() ^ Integer.rotateLeft(rgb[0],16) // ^ Integer.rotateLeft(rgb[1],8) ^ rgb[0]; return super .hashCode() ^ Arrays. hashCode ( rgb ); } }\npublic class Pixel { // ... @Override public boolean equals(Object obj) { if (!(obj instanceof Pixel)) return false ; Pixel p = (Pixel) obj; return ( x ==p. x ) && ( y ==p. y ); } @Override public int hashCode() { return Integer. rotateLeft ( x ,16) ^ y ; }\npublic static void main(String a){ Pixel zero = new Pixel(0,0); Pixel def = new Pixel(); HashSet set = new HashSet(); set.add(zero); set.contains(def); // true zero.hashCode(); // 0 def.hashCode(); // O zero.equals(def); // true }"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 79,
    "type": "paragraph",
    "text": "Etienne DURIS © ESIPE­MLV Université Paris­Est Marne­la­Vallée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 79,
    "type": "paragraph",
    "text": "79"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 79,
    "type": "paragraph",
    "text": "Les classes et méthodes « final »"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 79,
    "type": "section",
    "text": "➢ Le mot­clé final existe pour les méthodes :"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 79,
    "type": "paragraph",
    "text": "➢ Il signifie que la méthode ne pourra pas être redéfinie dans une"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 79,
    "type": "paragraph",
    "text": "sous­classe"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 79,
    "type": "paragraph",
    "text": "➢ Peut être utile pour garantir qu'aucune autre définition ne pourra"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 79,
    "type": "paragraph",
    "text": "être donnée pour cette méthode (sécurité)"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 79,
    "type": "section",
    "text": "➢ Le mot­clé final existe pour les classes :"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 79,
    "type": "paragraph",
    "text": "➢ Il devient alors impossible d'hériter de cette classe"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 79,
    "type": "paragraph",
    "text": "➢ Les méthodes se comportent comme si elles étaient final"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 80,
    "type": "paragraph",
    "text": "Etienne DURIS © ESIPE­MLV Université Paris­Est Marne­la­Vallée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 80,
    "type": "paragraph",
    "text": "80"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 80,
    "type": "paragraph",
    "text": "Les interfaces"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 80,
    "type": "section",
    "text": "➢ Une classe définit:"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 80,
    "type": "paragraph",
    "text": "➢ Un type"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 80,
    "type": "paragraph",
    "text": "➢ Une structure de données pour les instances (les champs)"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 80,
    "type": "paragraph",
    "text": "➢ Des méthodes avec leur code (leur définition)"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 80,
    "type": "section",
    "text": "➢ Une interface définit:"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 80,
    "type": "paragraph",
    "text": "➢ Un type"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 80,
    "type": "paragraph",
    "text": "➢ Des méthodes sans leur code (méthodes abstraites )"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 80,
    "type": "paragraph",
    "text": "➢ Une interface ne peut pas être instanciée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 80,
    "type": "paragraph",
    "text": "➢ Elle est destinée à être « implémentée » par des classes"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 80,
    "type": "paragraph",
    "text": "➢ À qui elle donnera son type"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 80,
    "type": "paragraph",
    "text": "➢ Qui fourniront des définitions pour les méthodes déclarées (code)"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 81,
    "type": "paragraph",
    "text": "Etienne DURIS © ESIPE­MLV Université Paris­Est Marne­la­Vallée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 81,
    "type": "paragraph",
    "text": "81"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 81,
    "type": "paragraph",
    "text": "Intérêt des interfaces"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 81,
    "type": "paragraph",
    "text": "➢ Donner un type commun à des classes différentes pour en faire"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 81,
    "type": "paragraph",
    "text": "un même usage"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 81,
    "type": "section",
    "text": "➢ Exemple:"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 81,
    "type": "paragraph",
    "text": "➢ Manipuler des tableaux de « trucs » qui ont chacun une surface"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 81,
    "type": "paragraph",
    "text": "➢ Faire la somme des surfaces des trucs qui sont dans le tableau"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 81,
    "type": "code_block",
    "text": "public class AlgoOnTrucs { public static double totalSurface(Surfaceable array) { double total = 0.0; for ( Surfaceable truc : array) total += truc.surface() ; return total; } }\npublic interface Surfaceable { public double surface(); }"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 82,
    "type": "paragraph",
    "text": "Etienne DURIS © ESIPE­MLV Université Paris­Est Marne­la­Vallée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 82,
    "type": "paragraph",
    "text": "82"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 82,
    "type": "paragraph",
    "text": "Utilisation d'interface"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 82,
    "type": "section",
    "text": "➢ Les 2 principaux avantages:"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 82,
    "type": "paragraph",
    "text": "➢ L'algo de la méthode totalSurface(Surfaceable array) fonctionne"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 82,
    "type": "diagram_element",
    "text": "indépendamment de la classe réelle des objets qui sont stockés dans array : c'est le sous­typage"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 82,
    "type": "paragraph",
    "text": "➢ La méthode surface() effectivement appelée sur les objets"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 82,
    "type": "diagram_element",
    "text": "contenus dans le tableau sera la plus précise possible , en fonction du type réel de cet objet: c'est le polymorphisme"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 82,
    "type": "code_block",
    "text": "public class AlgoOnTrucs {\npublic static double totalSurface(Surfaceable array) { ... }\npublic static void main(String args) { Rectangle rectangle = new Rectangle(2,5); Square square = new Square(10); Circle circle = new Circle(1); Surfaceable  t = {rectangle, square, circle}; System. out .println( totalSurface (t)); // 113.1415926535898 } }"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 83,
    "type": "paragraph",
    "text": "Etienne DURIS © ESIPE­MLV Université Paris­Est Marne­la­Vallée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 83,
    "type": "paragraph",
    "text": "83"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 83,
    "type": "paragraph",
    "text": "Implémentation d'interface"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 83,
    "type": "code_block",
    "text": "public class Square implements Surfaceable { private final double side ; public Square( double side) { this . side = side; } @Override public double surface() { return side * side ; } }\npublic class Rectangle implements Surfaceable { private final double height ; private final double width ; public Rectangle( double height, double width) { this . height = height; this . width = width; } @Override public double surface() { return height * width ; } }ﾲ public class Circle implements Surfaceable { private final double radius ; public Circle( double radius) { this . radius = radius; } @Override public double surface() { return Math. PI * radius * radius ; } }"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 84,
    "type": "paragraph",
    "text": "Etienne DURIS © ESIPE­MLV Université Paris­Est Marne­la­Vallée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 84,
    "type": "paragraph",
    "text": "84"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 84,
    "type": "paragraph",
    "text": "Les membres des interfaces"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 84,
    "type": "paragraph",
    "text": "➢ Contiennent des déclarations de méthode publiques"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 84,
    "type": "paragraph",
    "text": "➢ Toutes les méthodes sont"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 84,
    "type": "code_line",
    "text": "abstract public"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 84,
    "type": "paragraph",
    "text": "➢ même si non spécifié"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 84,
    "type": "paragraph",
    "text": "➢ Peuvent définir des champs publiques constants"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 84,
    "type": "paragraph",
    "text": "➢ Tous les champs sont"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 84,
    "type": "code_line",
    "text": "public final static"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 84,
    "type": "paragraph",
    "text": "➢ Le compilateur ajoute"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 84,
    "type": "paragraph",
    "text": "les mot­clés"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 84,
    "type": "paragraph",
    "text": "➢ Il n'est pas possible d'instancier une interface"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 84,
    "type": "paragraph",
    "text": "➢ On ne peut que déclarer des variables avec leur type"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 84,
    "type": "paragraph",
    "text": "➢ Ces variables pourront reçevoir des références à des objets qui"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 84,
    "type": "paragraph",
    "text": "sont des instances d'une classe qui implémente l'interface"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 84,
    "type": "code_block",
    "text": "public interface Surfaceable { double surface(); // equivaut à public abstract double surface(); }\npublic interface I { int field = 10; // equivaut à public final static int field = 10; }"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 85,
    "type": "paragraph",
    "text": "Etienne DURIS © ESIPE­MLV Université Paris­Est Marne­la­Vallée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 85,
    "type": "paragraph",
    "text": "85"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 85,
    "type": "paragraph",
    "text": "Implémentation d'interface et sous­typage"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 85,
    "type": "paragraph",
    "text": "➢ Une classe peut implémenter une interface"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 85,
    "type": "paragraph",
    "text": "➢ Mot clé implements"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 85,
    "type": "paragraph",
    "text": "➢ La classe Rectangle définit un sous­type de Surfaceable"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 85,
    "type": "paragraph",
    "text": "➢ Une interface ne peut pas implémenter une autre interface"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 85,
    "type": "paragraph",
    "text": "➢ On ne saurait pas comment implémenter les méthodes"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 85,
    "type": "code_block",
    "text": "public class Rectangle implements Surfaceable { ... }\nSurfaceable s = null;\ns = new Rectangle (2,5);"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 86,
    "type": "paragraph",
    "text": "Etienne DURIS © ESIPE­MLV Université Paris­Est Marne­la­Vallée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 86,
    "type": "paragraph",
    "text": "86"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 86,
    "type": "paragraph",
    "text": "Sous­typage entre interfaces"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 86,
    "type": "paragraph",
    "text": "➢ Une interface peut hériter d' une ou plusieurs autres interfaces"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 86,
    "type": "paragraph",
    "text": "➢ Mot clé extends"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 86,
    "type": "paragraph",
    "text": "➢ Le type Paintable est un sous­type de Surfaceable"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 86,
    "type": "paragraph",
    "text": "➢ Séparer les super­types"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 86,
    "type": "paragraph",
    "text": "avec des virgules"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 86,
    "type": "paragraph",
    "text": "➢ Le type SurfaceableAndMoveable définit un sous­type des deux"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 86,
    "type": "paragraph",
    "text": "types Surfaceable et de Moveable ( sous­typage multiple )"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 86,
    "type": "paragraph",
    "text": "➢ SurfaceableAndMoveable < Surfaceable et"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 86,
    "type": "paragraph",
    "text": "SurfaceableAndMoveable < Moveable"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 86,
    "type": "paragraph",
    "text": "➢ Ces deux dernières n'ont aucune relation entre­elles"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 86,
    "type": "code_block",
    "text": "public interface Paintable extends Surfaceable { double paint( byte  color, int layers); }\npublic interface SurfaceableAndMoveable extends Surfaceable, Moveable { ... }\nSurfaceable array = new Surfaceable[3]; // On peut créer des tableaux! Paintable p = null ; array[0] = p; // OK: Paintable < Surfaceable p = array[1]; // Cannot convert from Surfaceable to Paintable"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 87,
    "type": "paragraph",
    "text": "Etienne DURIS © ESIPE­MLV Université Paris­Est Marne­la­Vallée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 87,
    "type": "paragraph",
    "text": "87"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 87,
    "type": "diagram_element",
    "text": "Héritage de classe et implémentation d'interfaces: sous­typage multiple"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 87,
    "type": "paragraph",
    "text": "➢ Une classe peut hériter d'une classe et implémenter plusieurs"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 87,
    "type": "code_line",
    "text": "interfaces public class SolidCircle extends Circle implements Paintable , Moveable { private final Point center ; public SolidCircle(Point center, double radius) { super (radius); this . center = center; } @Override // Pour pouvoir implémenter Paintable public double paint( byte  color, int layers) { // doThePaintingJob(color,layers); return layers * surface(); // SolidCircle < Circle < Surfaceable } @Override // Pour pouvoir implémenter Moveable public void moveTo( int x, int y) { center .moveTo(x,y); } public static void main(String args) { SolidCircle sc = new SolidCircle( new Point(0,0), 3); Circle c = sc; double d = c.surface(); // SolidCircle < Circle Paintable p = sc; p.paint( new byte {0,0,0},2); // SolidCircle < Paintable Moveable m = sc; m.moveTo(1, 1); // SolidCircle < Moveable } }"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 88,
    "type": "paragraph",
    "text": "Etienne DURIS © ESIPE­MLV Université Paris­Est Marne­la­Vallée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 88,
    "type": "paragraph",
    "text": "88"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 88,
    "type": "paragraph",
    "text": "Vérifications du compilateur"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 88,
    "type": "paragraph",
    "text": "➢ Toutes les méthodes déclarées (abstract) dans l'ensemble"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 88,
    "type": "paragraph",
    "text": "des interfaces dont on revendique l'implémentation doivent être implantées"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 88,
    "type": "paragraph",
    "text": "➢ Définies avec leur code"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 88,
    "type": "paragraph",
    "text": "➢ Le modificateur de visibilité ne peut pas être autre chose que"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 88,
    "type": "paragraph",
    "text": "public"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 88,
    "type": "paragraph",
    "text": "➢ Même si on a mis la visibilité par défaut dans l'interface, le"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 88,
    "type": "paragraph",
    "text": "compilateur y ajoute public abstract"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 88,
    "type": "paragraph",
    "text": "➢ Que se passe t il si plusieurs méthodes de même nom et même"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 88,
    "type": "paragraph",
    "text": "signature de différentes interfaces doivent être implémentées dans la même classe?"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 89,
    "type": "paragraph",
    "text": "Etienne DURIS © ESIPE­MLV Université Paris­Est Marne­la­Vallée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 89,
    "type": "paragraph",
    "text": "89"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 89,
    "type": "paragraph",
    "text": "Pourquoi pas hériter de plusieurs classes"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 89,
    "type": "paragraph",
    "text": "➢ A cause des champs (diamant)"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 89,
    "type": "paragraph",
    "text": "➢ Qui pourraient provenir"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 89,
    "type": "paragraph",
    "text": "de deux classes dont on hérite et qui devraient « coexister » dans un même objet!"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 89,
    "type": "paragraph",
    "text": "➢ L'héritage multiple d'interfaces ne pose pas de problèmes"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 89,
    "type": "paragraph",
    "text": "➢ Au même titre que l'implémentation multiple d'interfaces"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 89,
    "type": "paragraph",
    "text": "➢ On « récupére » par héritage uniquement"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 89,
    "type": "paragraph",
    "text": "➢ des déclarations de méthodes (qui ne possèdent pas de définition)"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 89,
    "type": "paragraph",
    "text": "➢ des constantes dont la portée est limitée à l'interface dans laquelle"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 89,
    "type": "paragraph",
    "text": "elles sont définies (espace de nom)"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 89,
    "type": "diagram",
    "text": "Object\nA\nx:int\nB\nx:int\nC\nx:int C c"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 89,
    "type": "code_block",
    "text": "#1 @class C\n#1\nx = 1\nx = 2\nx = 3"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 89,
    "type": "paragraph",
    "text": "?"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 89,
    "type": "paragraph",
    "text": "?"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 89,
    "type": "paragraph",
    "text": "?"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 90,
    "type": "paragraph",
    "text": "Etienne DURIS © ESIPE­MLV Université Paris­Est Marne­la­Vallée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 90,
    "type": "paragraph",
    "text": "90"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 90,
    "type": "diagram_element",
    "text": "Design: interface ou héritage"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 90,
    "type": "paragraph",
    "text": "➢ On hérite d'une classe"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 90,
    "type": "paragraph",
    "text": "➢ pour créer un nouveau type qui est « une sorte particulière » de"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 90,
    "type": "paragraph",
    "text": "classe de base"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 90,
    "type": "paragraph",
    "text": "➢ On définit une interface et on l'implémente"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 90,
    "type": "paragraph",
    "text": "➢ Pour une fonctionnalité transverse"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 90,
    "type": "table_row",
    "text": "➢ Comparable, Closeable, Mesurable, Déplacable..."
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 90,
    "type": "paragraph",
    "text": "➢ Pour regrouper un ensemble de fonctionalités qui pourront être"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 90,
    "type": "paragraph",
    "text": "implémentées par des instances qui en implantent déjà d'autres (ou qui héritent d'une autre classe)"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 90,
    "type": "paragraph",
    "text": "➢ class RandomAccessFile extends Object"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 90,
    "type": "code_line",
    "text": "implements DataOutput , DataInput , Closeable {...}"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 91,
    "type": "paragraph",
    "text": "Etienne DURIS © ESIPE­MLV Université Paris­Est Marne­la­Vallée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 91,
    "type": "paragraph",
    "text": "91"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 91,
    "type": "paragraph",
    "text": "Les classes abstraites"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 91,
    "type": "paragraph",
    "text": "➢ Dans une interface , tout doit être abstrait (méthodes)"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 91,
    "type": "paragraph",
    "text": "➢ Les méthodes doivent toutes être abstraites"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 91,
    "type": "paragraph",
    "text": "➢ Elles ne peuvent être que publiques"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 91,
    "type": "paragraph",
    "text": "➢ Dans une classe, tout doit être concret"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 91,
    "type": "paragraph",
    "text": "➢ Les méthodes doivent être définies (leur code)"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 91,
    "type": "paragraph",
    "text": "➢ Elles peuvent avoir des modificateurs de visibilités différents"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 91,
    "type": "paragraph",
    "text": "➢ Une classe abstraite permet de créer une type à mi­chemin"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 91,
    "type": "paragraph",
    "text": "➢ Il s'agit d'une classe qui peut avoir des méthodes abstraites"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 91,
    "type": "paragraph",
    "text": "➢ Elle est considérée comme partiellement implantée, donc non"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 91,
    "type": "paragraph",
    "text": "instanciable"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 91,
    "type": "paragraph",
    "text": "➢ Elle peut éventuellement n'avoir aucune méthode abstraite"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 91,
    "type": "paragraph",
    "text": "➢ Le mot­clé abstract fait qu'elle n'est pas instanciable"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 92,
    "type": "paragraph",
    "text": "Etienne DURIS © ESIPE­MLV Université Paris­Est Marne­la­Vallée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 92,
    "type": "paragraph",
    "text": "92"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 92,
    "type": "paragraph",
    "text": "Si mon algo manipule un type..."
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 92,
    "type": "paragraph",
    "text": "➢ ... sur lequel je sais faire des choses, mais pas tout!"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 92,
    "type": "code_line",
    "text": "public class AlgoOnTrucs { public static double totalSurface( Surfaceable  array) { double total = 0.0; for (Surfaceable truc : array) total += truc.surface (); return total; } public static Surfaceable theBigger( Surfaceable  array) { Surfaceable bigger = array[0]; for ( int i = 1; i<array. length ; i++) { if (array[i]. biggerThan(bigger) ) bigger = array[i]; } return bigger; } public static void main(String args) { Rectangle rectangle = new Rectangle(2,5); Square square = new Square(10); Circle circle = new Circle(1); Surfaceable t = {rectangle, square, circle}; System. out .println( totalSurface (t)); // 113.1415926535898 System. out .println( theBigger (t)); // Square@a6eb38a } }"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 92,
    "type": "paragraph",
    "text": "Le code de surface() ne peut être défini"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 92,
    "type": "paragraph",
    "text": "que dans la classe « concrète »"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 92,
    "type": "paragraph",
    "text": "Mais je peux écrire un code pour biggerThan() qui ne dépend pas de"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 92,
    "type": "paragraph",
    "text": "cette classe concrète"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 93,
    "type": "paragraph",
    "text": "Etienne DURIS © ESIPE­MLV Université Paris­Est Marne­la­Vallée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 93,
    "type": "paragraph",
    "text": "93"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 93,
    "type": "paragraph",
    "text": "Exemple de classe abstraite"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 93,
    "type": "paragraph",
    "text": "➢ L'implémentation de la méthode biggerThan() marchera dès"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 93,
    "type": "code_block",
    "text": "qu'on l'appelera sur un objet (instance) d'une classe concrète, puisque celle­ci aura donné l'implémentation de la méthode surface(). public abstract class Surfaceable { public abstract double surface(); public boolean biggerThan(Surfaceable bigger) { return surface() > bigger.surface(); } }\npublic class Rectangle extends Surfaceable { ... } public class Circle extends Surfaceable { ... } public class Square extends Surfaceable { private final double side ; public Square( double side) { this . side = side; } @Override public double surface() { return side * side ; } }"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 94,
    "type": "paragraph",
    "text": "Etienne DURIS © ESIPE­MLV Université Paris­Est Marne­la­Vallée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 94,
    "type": "paragraph",
    "text": "94"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 94,
    "type": "paragraph",
    "text": "Les Exceptions"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 94,
    "type": "paragraph",
    "text": "➢ Mécanisme qui permet de reporter des erreurs vers les"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 94,
    "type": "paragraph",
    "text": "méthodes appelantes"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 94,
    "type": "paragraph",
    "text": "➢ « à travers » la pile d'appel des méthodes"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 94,
    "type": "paragraph",
    "text": "➢ avec la possibilité d'intercepter/traiter ou de propager"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 94,
    "type": "section",
    "text": "➢ Problème en C :"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 94,
    "type": "paragraph",
    "text": "➢ prévoir une plage de valeurs dans la valeur de retour pour"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 94,
    "type": "paragraph",
    "text": "signaler les erreurs."
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 94,
    "type": "paragraph",
    "text": "➢ Propager les erreurs “manuellement”"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 94,
    "type": "code_line",
    "text": "➢ En Java comme en C++, le mécanisme de remonté d’erreur est"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 94,
    "type": "paragraph",
    "text": "gérée par le langage."
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 95,
    "type": "paragraph",
    "text": "Etienne DURIS © ESIPE­MLV Université Paris­Est Marne­la­Vallée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 95,
    "type": "paragraph",
    "text": "95"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 95,
    "type": "paragraph",
    "text": "Exemple d'exception"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 95,
    "type": "paragraph",
    "text": "Un exemple simple"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 95,
    "type": "section",
    "text": "Lors de l’exécution :"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 95,
    "type": "code_line",
    "text": "public class ExceptionExample { public static char charAt(char array,int index) { return array[index]; } public static void main(String args) { char array=args[0].toCharArray(); charAt(array,0); } }"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 95,
    "type": "diagram_element",
    "text": "C:\\eclipse\\workspace\\java-avancé> java ExceptionExample Exception in thread \"main\" java.lang.ArrayIndexOutOfBoundsException : 0 at ExceptionExample.main( ExceptionExample.java:18 )"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 96,
    "type": "paragraph",
    "text": "Etienne DURIS © ESIPE­MLV Université Paris­Est Marne­la­Vallée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 96,
    "type": "paragraph",
    "text": "96"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 96,
    "type": "paragraph",
    "text": "Exemple d'exception (suite)"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 96,
    "type": "section",
    "text": "En reprenant le même exemple :"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 96,
    "type": "code_line",
    "text": "public class ExceptionExample { public static char charAt(char array,int index) { if (index<0 || index>=array.length) throw new IllegalArgumentException (\"bad index \"+index); return array[index]; } public static void main(String args) { char array=args[0].toCharArray(); charAt(array,0); charAt(array,1000); } }"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 96,
    "type": "diagram_element",
    "text": "C:\\eclipse\\workspace\\java-avancé> java ExceptionExample toto Exception in thread \"main\" java.lang.IllegalArgumentException : bad index 1000 at ExceptionExample.charAt( ExceptionExample.java:13 ) at ExceptionExample.main(ExceptionExample.java:20)"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 97,
    "type": "paragraph",
    "text": "Etienne DURIS © ESIPE­MLV Université Paris­Est Marne­la­Vallée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 97,
    "type": "paragraph",
    "text": "97"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 97,
    "type": "paragraph",
    "text": "Types d'exceptions"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 97,
    "type": "paragraph",
    "text": "Il existe en Java tout une hiérarchie de « types » d'exceptions"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 97,
    "type": "paragraph",
    "text": "Arbre de sous­typage des exceptions"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 97,
    "type": "diagram_element",
    "text": "Throwable"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 97,
    "type": "paragraph",
    "text": "Error Exception"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 97,
    "type": "diagram_element",
    "text": "RuntimeException"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 98,
    "type": "paragraph",
    "text": "Etienne DURIS © ESIPE­MLV Université Paris­Est Marne­la­Vallée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 98,
    "type": "paragraph",
    "text": "98"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 98,
    "type": "paragraph",
    "text": "Types d'exceptions (2)"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 98,
    "type": "paragraph",
    "text": "Throwable est la classe « mère » de toutes les exceptions"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 98,
    "type": "paragraph",
    "text": "Les Error correspondent à des exceptions qu'il est rare d'attraper."
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 98,
    "type": "paragraph",
    "text": "Les RuntimeException que l'on peut rattraper mais que l'on n'est pas obligé."
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 98,
    "type": "paragraph",
    "text": "Les Exception que l'on est obligé d'attraper ( try/catch ) ou de dire que la méthode appelante devra s'en occuper ( throws )."
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 99,
    "type": "paragraph",
    "text": "Etienne DURIS © ESIPE­MLV Université Paris­Est Marne­la­Vallée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 99,
    "type": "paragraph",
    "text": "99"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 99,
    "type": "section",
    "text": "Les exceptions levées par la VM correspondent :"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 99,
    "type": "paragraph",
    "text": "Erreur de compilation ou de lancement"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 99,
    "type": "paragraph",
    "text": "NoClassDefFoundError, ClassFormatError"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 99,
    "type": "section",
    "text": "problème d'entrée/sortie :"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 99,
    "type": "paragraph",
    "text": "IOException, AWTException"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 99,
    "type": "section",
    "text": "problème de ressource :"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 99,
    "type": "paragraph",
    "text": "OutOfMemoryError, StackOverflowError"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 99,
    "type": "paragraph",
    "text": "des erreurs de programmation (runtime)"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 99,
    "type": "paragraph",
    "text": "NullPointerException, ArrayIndexOutOfBoundsException, ArithmethicException"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 99,
    "type": "paragraph",
    "text": "Exceptions levées par la VM"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 100,
    "type": "paragraph",
    "text": "Etienne DURIS © ESIPE­MLV Université Paris­Est Marne­la­Vallée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 100,
    "type": "paragraph",
    "text": "100"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 100,
    "type": "paragraph",
    "text": "Attraper une exception"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 100,
    "type": "paragraph",
    "text": "try/catch permet d'attraper les exceptions"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 100,
    "type": "code_line",
    "text": "public class CatchExceptionExample { public static void main(String args) { int value; try { value=Integer.parseInt(args[0]); } catch( NumberFormatException e ) { value=0; } System.out.println(\"value \"+value); } }"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 101,
    "type": "paragraph",
    "text": "Etienne DURIS © ESIPE­MLV Université Paris­Est Marne­la­Vallée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 101,
    "type": "paragraph",
    "text": "101"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 101,
    "type": "paragraph",
    "text": "Attraper une exception"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 101,
    "type": "paragraph",
    "text": "try/catch définit obligatoirement un bloc."
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 101,
    "type": "code_line",
    "text": "public class CatchExceptionExample { public static void main(String args) { int value; try { value=Integer.parseInt(args[0]); } catch( ArrayIndexOutOfBoundsException e ) { System.err.println(\"no argument\"); e.printStackTrace (); return ; } catch( NumberFormatException e ) { value=0; } System.out.println(\"value \"+value); } }"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 101,
    "type": "paragraph",
    "text": "Sinon cela ne"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 101,
    "type": "paragraph",
    "text": "compile pas car value n'est"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 101,
    "type": "paragraph",
    "text": "pas intitialisée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 102,
    "type": "paragraph",
    "text": "Etienne DURIS © ESIPE­MLV Université Paris­Est Marne­la­Vallée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 102,
    "type": "paragraph",
    "text": "102"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 102,
    "type": "paragraph",
    "text": "Attraper une exception"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 102,
    "type": "paragraph",
    "text": "Attention, les blocs catch sont testés dans l'ordre d'écriture !"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 102,
    "type": "paragraph",
    "text": "Un catch inatteignable est une erreur"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 102,
    "type": "code_line",
    "text": "public class CatchExceptionExample { public static void main(String args) { int value; try { value=... } catch(Exception e) { value=1; } catch( IOException e ) { // jamais appelé value=0; } System.out.println(\"value \"+value); } }"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 102,
    "type": "diagram",
    "text": "Exception\nIOException"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 103,
    "type": "paragraph",
    "text": "Etienne DURIS © ESIPE­MLV Université Paris­Est Marne­la­Vallée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 103,
    "type": "paragraph",
    "text": "103"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 103,
    "type": "paragraph",
    "text": "Ne pas attraper tout ce qui bouge"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 103,
    "type": "paragraph",
    "text": "Comment passer des heures à débugger;­)"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 103,
    "type": "paragraph",
    "text": "Éviter les catch(Throwable) ou catch(Exception) !!"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 103,
    "type": "code_line",
    "text": "public static void aRandomThing(String args) { return Integer.parseInt(args[-1]); } public static void main(String args) { ... try { aRandomThing(args); } catch( Throwable t ) { // surtout ne rien faire sinon c'est pas drôle } ... }"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 104,
    "type": "paragraph",
    "text": "Etienne DURIS © ESIPE­MLV Université Paris­Est Marne­la­Vallée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 104,
    "type": "paragraph",
    "text": "104"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 104,
    "type": "paragraph",
    "text": "La directive throws"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 104,
    "type": "paragraph",
    "text": "Indique qu'une exception peut­être levée dans le code mais que celui­ci ne la gère pas (pas de try/catch)."
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 104,
    "type": "paragraph",
    "text": "throws n'est obligatoire que pour les Exception"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 104,
    "type": "paragraph",
    "text": "pas les erreurs (Error)"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 104,
    "type": "paragraph",
    "text": "ni pour ou les runtimes (RuntimeException)"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 104,
    "type": "code_line",
    "text": "public static void f(String author) throws OhNoException { if (\"dan brown\".equals(author)) throw new OhNoException(\"oh no\"); } public static void main(String args) { try { f(args[0]); } catch(OhNoException e ) { tryToRecover(); }"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 105,
    "type": "paragraph",
    "text": "Etienne DURIS © ESIPE­MLV Université Paris­Est Marne­la­Vallée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 105,
    "type": "paragraph",
    "text": "105"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 105,
    "type": "paragraph",
    "text": "Alors throws ou catch"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 105,
    "type": "paragraph",
    "text": "➢ Si on appelle une méthode qui lève une exception non runtime"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 105,
    "type": "paragraph",
    "text": "➢ catch si l'on peut reprendre sur l'erreur et faire quelque chose de"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 105,
    "type": "paragraph",
    "text": "cohérent (appliquer une action corrective)"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 105,
    "type": "paragraph",
    "text": "➢ Sinon throws pour propager l'exception vers celui qui a appelé la"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 105,
    "type": "paragraph",
    "text": "méthode qui fera ce qu'il doit faire"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 106,
    "type": "paragraph",
    "text": "Etienne DURIS © ESIPE­MLV Université Paris­Est Marne­la­Vallée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 106,
    "type": "paragraph",
    "text": "106"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 106,
    "type": "paragraph",
    "text": "Un exemple"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 106,
    "type": "paragraph",
    "text": "La même exception peut être capturée ou propagée selon le contexte"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 106,
    "type": "code_block",
    "text": "public static Config initConfig(String userName) throws IOException {\nConfig conf = null ; FileInputStream fis = null ; try { fis = new FileInputStream(userName+ \"_config\" ); conf = new Config(userName); } catch (FileNotFoundException e) { // no config file for this user... e.printStackTrace(System. err ); fis = new FileInputStream( \"default_config\" ); conf = new Config(userName); } readConfFromInputStream (conf,fis); fis.close(); return conf; }"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 107,
    "type": "paragraph",
    "text": "Etienne DURIS © ESIPE­MLV Université Paris­Est Marne­la­Vallée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 107,
    "type": "paragraph",
    "text": "107"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 107,
    "type": "paragraph",
    "text": "Le bloc finally"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 107,
    "type": "paragraph",
    "text": "Sert à exécuter un code quoi qu'il arrive (fermer un fichier, une connexion, libérer une ressources)"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 107,
    "type": "paragraph",
    "text": "Le catch n'est pas obligatoire."
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 107,
    "type": "code_line",
    "text": "public class FinallyExceptionExample { public static void main(String args) { ReentrantLock lock = new ReentrantLock(); lock.lock(); try { doSomething(); } finally { lock.unlock() } } }"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 108,
    "type": "paragraph",
    "text": "Etienne DURIS © ESIPE­MLV Université Paris­Est Marne­la­Vallée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 108,
    "type": "paragraph",
    "text": "108"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 108,
    "type": "paragraph",
    "text": "Exception et StackTrace"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 108,
    "type": "paragraph",
    "text": "Lors de la création d'une exception, la VM calcule le StackTrace"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 108,
    "type": "paragraph",
    "text": "Le StackTrace correspond aux fonctions empilées (dans la pile) lors de la création"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 108,
    "type": "paragraph",
    "text": "Le calcul du StackTrace est quelque chose de coûteux en performance."
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 109,
    "type": "paragraph",
    "text": "Etienne DURIS © ESIPE­MLV Université Paris­Est Marne­la­Vallée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 109,
    "type": "paragraph",
    "text": "109"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 109,
    "type": "paragraph",
    "text": "Le chaînage des exceptions"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 109,
    "type": "paragraph",
    "text": "➢ Il est possible d'encapsuler une exception dans une autre"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 109,
    "type": "paragraph",
    "text": "➢ new Exception(\"msg\", throwable)"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 109,
    "type": "paragraph",
    "text": "➢ new Exception(\"msg\").initCause(throwable)"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 109,
    "type": "paragraph",
    "text": "➢ Permet de lever une exception suffisamment précise tout en"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 109,
    "type": "paragraph",
    "text": "respectant une signature fixée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 110,
    "type": "paragraph",
    "text": "Etienne DURIS © ESIPE­MLV Université Paris­Est Marne­la­Vallée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 110,
    "type": "paragraph",
    "text": "110"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 110,
    "type": "paragraph",
    "text": "Le chaînage des exceptions (2)"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 110,
    "type": "paragraph",
    "text": "Comme close ne peut pas renvoyer d' Exception , on encapsule celle­ci"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 110,
    "type": "code_line",
    "text": "interface Closable { public void close() throws IOException ; } public class DB { public void flush() throws OhNoException { throw new OhNoException(\"argh !\"); } } public class ExceptionChain implements Closable { private final DB db=new DB(); public void close() throws IOException { try { db.flush(); } catch ( OhNoException e) { throw (IOException)new IOException().initCause(e) ; // ou à partir de la 1.6 throw new IOException(e); } } }"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 111,
    "type": "paragraph",
    "text": "Etienne DURIS © ESIPE­MLV Université Paris­Est Marne­la­Vallée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 111,
    "type": "paragraph",
    "text": "111"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 111,
    "type": "paragraph",
    "text": "Le chaînage des exceptions (3)"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 111,
    "type": "section",
    "text": "Exécution de l’exemple précédent :"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 111,
    "type": "section",
    "text": "Désencapsulation :"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 111,
    "type": "paragraph",
    "text": "Exception in thread \"main\" java.io.IOException"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 111,
    "type": "diagram",
    "text": "at ExceptionChain.close( ExceptionChain.java:27 ) at ExceptionChain.main( ExceptionChain.java:32 ) Caused by: fr.umlv.OhNoException : argh !\nat DB.fush( ExceptionChain.java:20 ) at ExceptionChain.close( ExceptionChain.java:25 ) ... 1 more"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 111,
    "type": "code_line",
    "text": "public static void caller() throws OhNoException { ExceptionChain chain=new ExceptionChain(); try { chain.close(); } catch(IOException e) { Thowable t=e. getCause (); if (t instanceof OhNoException) throw (OhNoException)t; ..."
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 112,
    "type": "paragraph",
    "text": "Etienne DURIS © ESIPE­MLV Université Paris­Est Marne­la­Vallée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 112,
    "type": "paragraph",
    "text": "112"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 112,
    "type": "paragraph",
    "text": "Le mot­clé assert"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 112,
    "type": "paragraph",
    "text": "Le mot­clé assert permet de s'assurer que la valeur d’une expression est vraie"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 112,
    "type": "section",
    "text": "Deux syntaxes :"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 112,
    "type": "code_block",
    "text": "assert test ; assert i==j;\nassert test : mesg ; assert i==j:\"i not equals to j\";"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 112,
    "type": "paragraph",
    "text": "Par défaut, les assert ne sont pas exécutés, il faut lancer java ­ea (enable assert)"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 113,
    "type": "paragraph",
    "text": "Etienne DURIS © ESIPE­MLV Université Paris­Est Marne­la­Vallée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 113,
    "type": "paragraph",
    "text": "113"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 113,
    "type": "paragraph",
    "text": "assert et AssertionError"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 113,
    "type": "paragraph",
    "text": "Si le test booléen du assert est faux, la VM lève une exception AssertionError"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 113,
    "type": "code_line",
    "text": "public class AssertExample { private static void check(List list) { assert list.isEmpty() || list.indexOf(list.get(0))!=-1; } public static void main(String args) { List list=new BadListImpl(); list.add(3); check(list); ... } }"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 114,
    "type": "paragraph",
    "text": "Etienne DURIS © ESIPE­MLV Université Paris­Est Marne­la­Vallée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 114,
    "type": "paragraph",
    "text": "114"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 114,
    "type": "paragraph",
    "text": "Exceptions et programmeur"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 114,
    "type": "section",
    "text": "➢ Le programmeur va utiliser des exceptions pour assurer :"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 114,
    "type": "paragraph",
    "text": "➢ Que son code est bien utilisé (pré­condition)"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 114,
    "type": "paragraph",
    "text": "➢ Que l'état de l'objet est bon (pré­condition)"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 114,
    "type": "paragraph",
    "text": "➢ Que le code fait ce qu'il doit faire"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 114,
    "type": "paragraph",
    "text": "(post­condition/invariant)"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 114,
    "type": "paragraph",
    "text": "➢ Il va de plus gérer toutes les exceptions qui ne sont pas"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 114,
    "type": "paragraph",
    "text": "runtime."
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 115,
    "type": "paragraph",
    "text": "Etienne DURIS © ESIPE­MLV Université Paris­Est Marne­la­Vallée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 115,
    "type": "paragraph",
    "text": "115"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 115,
    "type": "paragraph",
    "text": "Exception et prog. par contrat"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 115,
    "type": "section",
    "text": "➢ Habituellement, les :"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 115,
    "type": "section",
    "text": "➢ Pré­conditions sont utilisées pour :"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 115,
    "type": "paragraph",
    "text": "➢ vérifier les paramètres"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 115,
    "type": "paragraph",
    "text": "NullPointerException et IllegalArgumentException"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 115,
    "type": "paragraph",
    "text": "➢ vérifier l'état de l'objet"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 115,
    "type": "diagram_element",
    "text": "IllegalStateException"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 115,
    "type": "section",
    "text": "➢ Post­conditions sont utilisées pour :"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 115,
    "type": "paragraph",
    "text": "➢ vérifier que les opérations ont bien été effectués"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 115,
    "type": "paragraph",
    "text": "assert, AssertionError"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 115,
    "type": "section",
    "text": "➢ Invariants sont utilisées pour :"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 115,
    "type": "paragraph",
    "text": "➢ Vérifier que les invariants de l'algorithme sont préservés. assert,"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 115,
    "type": "diagram_element",
    "text": "AssertionError"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 116,
    "type": "paragraph",
    "text": "Etienne DURIS © ESIPE­MLV Université Paris­Est Marne­la­Vallée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 116,
    "type": "paragraph",
    "text": "116"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 116,
    "type": "diagram_element",
    "text": "Exemple"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 116,
    "type": "code_line",
    "text": "public class Stack { public Stack(int capacity) { array=new int[capacity]; } public void push(int value) { if (top>=array.length) throw new IllegalStateException (\"stack is full\"); array[top++]=value; assert array[top-1]==value; assert top>=0 && top<=array.length; } public int pop() { if (top<=0) throw new IllegalStateException (\"stack is empty\"); int value=array[--top]; assert top>=0 && top<=array.length; return value; } private int top; private final int array; }"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 116,
    "type": "paragraph",
    "text": "Pré-condition"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 116,
    "type": "paragraph",
    "text": "Post-condition"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 116,
    "type": "diagram_element",
    "text": "Invariant"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 117,
    "type": "paragraph",
    "text": "Etienne DURIS © ESIPE­MLV Université Paris­Est Marne­la­Vallée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 117,
    "type": "paragraph",
    "text": "117"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 117,
    "type": "paragraph",
    "text": "Exemple avec commentaires"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 117,
    "type": "paragraph",
    "text": "Le code doit être commenté"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 117,
    "type": "code_line",
    "text": "public class Stack { /** This class implements a fixed size stack of integers. * @ author remi */ public class Stack { /** put the value on top of the stack. * @ param value value to push in the stack. * @ throws IllegalStateException if the stack is full. */ public void push(int value) { ... } /** remove the value from top of the stack. * @ return the value on top of the stack. * @ throws IllegalStateException if the stack is empty. */ public int pop() {"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 118,
    "type": "paragraph",
    "text": "Etienne DURIS © ESIPE­MLV Université Paris­Est Marne­la­Vallée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 118,
    "type": "paragraph",
    "text": "118"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 118,
    "type": "paragraph",
    "text": "Utilisation de Javadoc"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 118,
    "type": "paragraph",
    "text": "C:\\java-avancé>javadoc src\\Stack.java Loading source file src\\Stack.java... Constructing Javadoc information... Standard Doclet version 1.5.0-beta3 Building tree for all the packages and classes... Generating Stack.html... Generating package-frame.html... ..."
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 119,
    "type": "paragraph",
    "text": "Etienne DURIS © ESIPE­MLV Université Paris­Est Marne­la­Vallée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 119,
    "type": "paragraph",
    "text": "119"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 119,
    "type": "paragraph",
    "text": "Programmation par exception"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 119,
    "type": "paragraph",
    "text": "Déclencher une exception pour l'attraper juste après est très rarement performant (la création du stacktrace coûte cher)"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 119,
    "type": "code_line",
    "text": "public class CatchExceptionExample { public static int sum1(int array) { // 5,4 ns int sum=0; for(int v:array) sum+=v; return sum; } public static int sum2(int array) { // 7,2 ns int sum=0; try { for(int i=0;;) sum+=array[i++]; } catch(ArrayIndexOutOfBoundsException e) { return sum; } } }"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 120,
    "type": "paragraph",
    "text": "Etienne DURIS © ESIPE­MLV Université Paris­Est Marne­la­Vallée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 120,
    "type": "paragraph",
    "text": "120"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 120,
    "type": "paragraph",
    "text": "StrackTrace et optimisation"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 120,
    "type": "paragraph",
    "text": "Pour des questions de performance, il est possible de pré­créer une exception"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 120,
    "type": "code_line",
    "text": "public class StackTraceExample { public static void f() { throw new RuntimeException(); } public static void g() { if (exception==null) exception=new RuntimeException(); throw exception; } private static RuntimeException exception; public static void main(String args) { f(); // 100 000 appels, moyenne()=3104 ns g(); // 100 000 appels, moyenne()=168 ns } }"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 121,
    "type": "paragraph",
    "text": "Etienne DURIS © ESIPE­MLV Université Paris­Est Marne­la­Vallée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 121,
    "type": "paragraph",
    "text": "121"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 121,
    "type": "paragraph",
    "text": "Appel de méthode"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 121,
    "type": "paragraph",
    "text": "L'algorithme d'appel de méthode s'effectue en deux temps"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 121,
    "type": "paragraph",
    "text": "1) A la compilation, on cherche la méthode la mieux adaptée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 121,
    "type": "paragraph",
    "text": "On recherche les méthodes applicables"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 121,
    "type": "paragraph",
    "text": "(celles que l'on peut appeler)"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 121,
    "type": "paragraph",
    "text": "Parmi les méthodes applicables, on recherche"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 121,
    "type": "paragraph",
    "text": "s'il existe une méthode plus spécifique (dont les paramètres seraient sous-types des paramètres des autres méthodes) 2) À l'exécution, on recherche l'implémentation de cette méthode"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 121,
    "type": "paragraph",
    "text": "qui soit la plus précise étant donné le type réel de l'objet receveur de l'appel"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 122,
    "type": "paragraph",
    "text": "Etienne DURIS © ESIPE­MLV Université Paris­Est Marne­la­Vallée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 122,
    "type": "paragraph",
    "text": "122"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 122,
    "type": "paragraph",
    "text": "Méthodes applicables"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 122,
    "type": "section",
    "text": "Ordre dans la recherche des méthodes applicables :"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 122,
    "type": "paragraph",
    "text": "Recherche des méthodes à nombre fixe d'argument en fonction du sous-typage & convertions primitifs"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 122,
    "type": "paragraph",
    "text": "Recherche des méthodes à nombre fixe d'argument en permettant l'auto-[un]boxing"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 122,
    "type": "paragraph",
    "text": "Recherche des méthodes en prenant en compte les varargs"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 122,
    "type": "paragraph",
    "text": "Dès qu'une des recherches trouve une ou plusieurs méthodes la recherche s'arrête"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 123,
    "type": "paragraph",
    "text": "Etienne DURIS © ESIPE­MLV Université Paris­Est Marne­la­Vallée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 123,
    "type": "paragraph",
    "text": "123"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 123,
    "type": "paragraph",
    "text": "Exemple de méthodes applicables"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 123,
    "type": "paragraph",
    "text": "Le compilateur cherche les méthodes applicables"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 123,
    "type": "paragraph",
    "text": "Ici, add(Object) et add(CharSequence) sont applicables"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 123,
    "type": "code_block",
    "text": "public class Example { public void add(Object value) { } public void add(CharSequence value) { } }\npublic static void main(String args) { Example example=new Example(); for (String arg:args) example.add(arg); }"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 124,
    "type": "paragraph",
    "text": "Etienne DURIS © ESIPE­MLV Université Paris­Est Marne­la­Vallée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 124,
    "type": "paragraph",
    "text": "124"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 124,
    "type": "paragraph",
    "text": "Méthode la plus spécifique"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 124,
    "type": "paragraph",
    "text": "Recherche parmi les méthodes applicables, la méthode la plus spécifique"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 124,
    "type": "paragraph",
    "text": "La méthode la plus spécifique est la méthode dont tous les paramètres sont sous­type des paramètres des autres méthodes"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 124,
    "type": "code_block",
    "text": "public class Example { public void add(Object value) { } public void add(CharSequence value) { } }\npublic static void main(String args) { Example example=new Example(); for (String arg:args) example.add(arg); // appel add(CharSequence) }"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 125,
    "type": "paragraph",
    "text": "Etienne DURIS © ESIPE­MLV Université Paris­Est Marne­la­Vallée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 125,
    "type": "paragraph",
    "text": "125"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 125,
    "type": "paragraph",
    "text": "Méthode la plus spécifique (2)"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 125,
    "type": "paragraph",
    "text": "Si aucune méthode n'est plus spécifique que les autres, il y a alors ambiguité"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 125,
    "type": "paragraph",
    "text": "Dans l'exemple, les deux méthodes add() sont applicables, aucune n'est plus précise"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 125,
    "type": "code_block",
    "text": "public class Example { public void add(Object v1, String v2) { } public void add(String v1, Object v2) { } }\npublic static void main(String args) { Example example=new Example(); for (String arg:args) example.add(arg,arg); // reference to add is ambiguous, both method // add(Object,String) and method add(String,Object) match }"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 126,
    "type": "paragraph",
    "text": "Etienne DURIS © ESIPE­MLV Université Paris­Est Marne­la­Vallée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 126,
    "type": "paragraph",
    "text": "126"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 126,
    "type": "paragraph",
    "text": "Surcharge et auto­[un]boxing"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 126,
    "type": "paragraph",
    "text": "Le boxing/unboxing n'est pas prioritaire par rapport à la valeur actuelle"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 126,
    "type": "code_block",
    "text": "public class List { public void remove(Object value) { } public void remove(int index) { } }\npublic static void main(String args) { List list=... int value=3; Integer box=value;\nlist.remove(value); // appel remove(int) list.remove(box); // appel remove(Object) }"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 127,
    "type": "paragraph",
    "text": "Etienne DURIS © ESIPE­MLV Université Paris­Est Marne­la­Vallée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 127,
    "type": "paragraph",
    "text": "127"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 127,
    "type": "paragraph",
    "text": "Surcharge et Varargs"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 127,
    "type": "paragraph",
    "text": "Une méthode à nombre variable d'arguments n'est pas prioritaire par rapport à une méthode à nombre fixe d'arguments"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 127,
    "type": "code_line",
    "text": "public class VarargsOverloading { private static int min(int... array) { } private static int min(double value) { } public static void main(String args) { min(2); // appel min(double) } }"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 128,
    "type": "paragraph",
    "text": "Etienne DURIS © ESIPE­MLV Université Paris­Est Marne­la­Vallée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 128,
    "type": "paragraph",
    "text": "128"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 128,
    "type": "paragraph",
    "text": "Surcharge et Varargs (2)"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 128,
    "type": "section",
    "text": "Surcharge entre deux varargs :"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 128,
    "type": "section",
    "text": "Choix entre deux varargs ayant même wrapper :"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 128,
    "type": "code_block",
    "text": "public class VarargsOverloading { private static void add(Object... array) { } private static void add(String ... array) { }\npublic static void main(String args) { add(args[0],args[1]); // appel add(String...) } }\npublic class VarargsOverloading { private static int min(int... array) { } private static int min(Integer... array) { } public static void main(String args) { min(2); // reference to min is ambiguous, both method // min(int...) and method min(Integer...) match } }"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 129,
    "type": "paragraph",
    "text": "Etienne DURIS © ESIPE­MLV Université Paris­Est Marne­la­Vallée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 129,
    "type": "paragraph",
    "text": "129"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 129,
    "type": "paragraph",
    "text": "Late­binding"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 129,
    "type": "paragraph",
    "text": "A l'exécution, on recherche l'implémentation la plus précise"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 129,
    "type": "paragraph",
    "text": "possible de la méthode identifiée à la compilation"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 129,
    "type": "code_block",
    "text": "public class A { public static void main(String args) { B b = new B(); C c = new D(); c.m(b); // Affiche C.m(A) } } class B extends A { }\nclass C { public void m(A a) { System. out .println( \"C.m(A)\" ); } } class D extends C { public void m(B b) { System. out .println( \"D.m(B)\" ); } }"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 130,
    "type": "paragraph",
    "text": "Etienne DURIS © ESIPE­MLV Université Paris­Est Marne­la­Vallée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 130,
    "type": "paragraph",
    "text": "130"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 130,
    "type": "paragraph",
    "text": "Quelques mots sur java.util"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 130,
    "type": "paragraph",
    "text": "➢ Contient de nombreuses classes « utilitaires »"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 130,
    "type": "paragraph",
    "text": "➢ Autour des tableaux, des collections..."
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 130,
    "type": "paragraph",
    "text": "➢ Contient également la plupart des classes, classes abstraites et"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 130,
    "type": "paragraph",
    "text": "interfaces sur les structures de données permettant de stocker des éléments"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 130,
    "type": "paragraph",
    "text": "➢ Listes"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 130,
    "type": "paragraph",
    "text": "➢ Ensembles"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 130,
    "type": "paragraph",
    "text": "➢ Tables d'associations"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 130,
    "type": "paragraph",
    "text": "➢ Files d'attente..."
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 131,
    "type": "paragraph",
    "text": "Etienne DURIS © ESIPE­MLV Université Paris­Est Marne­la­Vallée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 131,
    "type": "paragraph",
    "text": "131"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 131,
    "type": "paragraph",
    "text": "Opération sur les tableaux"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 131,
    "type": "paragraph",
    "text": "➢ La classe java.util.Arrays définit des méthodes statiques de"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 131,
    "type": "section",
    "text": "manipulation des tableaux :"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 131,
    "type": "paragraph",
    "text": "➢ equals(), hashCode(), toString()..."
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 131,
    "type": "paragraph",
    "text": "➢ binarySearch(), sort(), fill()"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 131,
    "type": "section",
    "text": "➢ Pour la copie de tableau, on utilise :"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 131,
    "type": "paragraph",
    "text": "➢ Object.clone(),System.arraycopy(), Arrays.copyOf()"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 132,
    "type": "paragraph",
    "text": "Etienne DURIS © ESIPE­MLV Université Paris­Est Marne­la­Vallée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 132,
    "type": "paragraph",
    "text": "132"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 132,
    "type": "paragraph",
    "text": "equals(), hashCode(), toString()"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 132,
    "type": "paragraph",
    "text": "➢ Les méthodes equals(), hashCode(), toString() ne sont pas"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 132,
    "type": "paragraph",
    "text": "redéfinies sur les tableaux"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 132,
    "type": "paragraph",
    "text": "➢ Arrays.equals(), Arrays.hashCode(),Arrays.toString() marchent"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 132,
    "type": "paragraph",
    "text": "pour Object et tous les types primitifs"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 132,
    "type": "code_line",
    "text": "int array=new int{2,3,5,6}; System.out.println(array); // [I@10b62c9 System.out.println( Arrays.toString (array)); // [2, 3, 5, 6] System.out.println(array.hashCode()); // 17523401 System.out.println( Arrays.hashCode (array)); // 986147 int array2=new int{2,3,5,6}; System.out.println(array2.hashCode()); // 8567361 System.out.println( Arrays.hashCode (array2)); // 986147 System.out.println(array.equals(array2)); // false System.out.println( Arrays.equals (array,array2)); // true"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 133,
    "type": "paragraph",
    "text": "Etienne DURIS © ESIPE­MLV Université Paris­Est Marne­la­Vallée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 133,
    "type": "paragraph",
    "text": "133"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 133,
    "type": "paragraph",
    "text": "binarySearch, sort, fill"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 133,
    "type": "paragraph",
    "text": "➢ Dichotomie (le tableau doit être trié)"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 133,
    "type": "paragraph",
    "text": "➢ Tri"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 133,
    "type": "paragraph",
    "text": "➢ Remplissage"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 133,
    "type": "table_row",
    "text": "binarySearch(byte a, byte key) ... binarySearch(Object a, Object key) <T> binarySearch(T a, T key, Comparator<? super T> c)"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 133,
    "type": "paragraph",
    "text": "sort(byte a) sort(byte a, int fromIndex, int toIndex) ... <T> sort(T a, Comparator<? super T> c) <T> sort(T a, int fromIndex, int toIndex, Comparator<? super T> c)"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 133,
    "type": "paragraph",
    "text": "fill(boolean a, boolean val) fill(boolean a, int fromIndex, int toIndex, boolean val) ... fill(Object a, Object val) fill(Object a, int fromIndex, int toIndex, Object val)"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 134,
    "type": "paragraph",
    "text": "Etienne DURIS © ESIPE­MLV Université Paris­Est Marne­la­Vallée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 134,
    "type": "paragraph",
    "text": "134"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 134,
    "type": "paragraph",
    "text": "Ordre naturel"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 134,
    "type": "paragraph",
    "text": "➢ Une classe peut spécifier un ordre naturel en implantant"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 134,
    "type": "paragraph",
    "text": "l'interface Comparable<T>"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 134,
    "type": "paragraph",
    "text": "➢ T doit être la classe spécifiant l'ordre"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 134,
    "type": "section",
    "text": "➢ Valeur de retour de compareTo(T t) :"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 134,
    "type": "paragraph",
    "text": "➢ <0 si this est inférieur à t"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 134,
    "type": "code_line",
    "text": "➢ ==0 si this est égal à t"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 134,
    "type": "paragraph",
    "text": "➢ >0 si this est supérieur à t"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 134,
    "type": "paragraph",
    "text": "➢ Exemple avec une classe Person"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 134,
    "type": "code_line",
    "text": "public interface Comparable<T> { int compareTo(T t); }"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 135,
    "type": "paragraph",
    "text": "Etienne DURIS © ESIPE­MLV Université Paris­Est Marne­la­Vallée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 135,
    "type": "paragraph",
    "text": "135"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 135,
    "type": "code_block",
    "text": "public class Person implements Comparable<Person> { private final String name , firstName ; private final int year ; public Person(String name, String firstName, int year) { this . name = name; this . firstName = firstName; this . year = year; } @Override public int compareTo(Person p) { int dName = name .compareTo(p. name ); if (dName != 0) return dName ; int dFirstName = firstName .compareTo(p. firstName );\nif (dFirstName != 0) return dFirstName; return year - p. year ; } @Override public boolean equals(Object o) { if (!(o instanceof Person)) return false ; Person p=(Person)o ; return name .equals(p. name ) && firstName .equals(p. firstName ) && year == p. year ; } @Override public String toString() { return \"(\" + name + \" \" + firstName + \" \" + year + \")\" ; }"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 135,
    "type": "paragraph",
    "text": "compareTo() et equals() doivent être « compatibles »"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 136,
    "type": "paragraph",
    "text": "Etienne DURIS © ESIPE­MLV Université Paris­Est Marne­la­Vallée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 136,
    "type": "paragraph",
    "text": "136"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 136,
    "type": "paragraph",
    "text": "Cet ordre « naturel » est intrinsèque"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 136,
    "type": "code_line",
    "text": "public class Person implements Comparable<Person> { // ... @Override public boolean equals(Object o) { //... @Override public String toString() { //... @Override public int compareTo(Person p) { //... public static void main(String args) { Person array = { new Person( \"Toto\" , \"Titi\" ,1990), new Person( \"Toto\" , \"Titi\" ,1900), new Person( \"Toto\" , \"Abdel\" ,1990), new Person( \"Toto\" , \"Zora\" ,1990), new Person( \"Dudu\" , \"Titi\" ,1950), new Person( \"Paupau\" , \"Seb\" ,2010)}; System. out .println(Arrays. toString (array)); Arrays. sort (array); System. out .println(Arrays. toString (array)); } } Affiche: [(Toto Titi 1990), (Toto Titi 1900), (Toto Abdel 1990), (Toto Zora 1990), (Dudu Titi 1950), (Paupau Seb 2010)] [(Dudu Titi 1950), (Paupau Seb 2010), (Toto Abdel 1990), (Toto Titi 1900), (Toto Titi 1990), (Toto Zora 1990)]"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 136,
    "type": "paragraph",
    "text": "➢ Il est défini « dans » la classe"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 137,
    "type": "paragraph",
    "text": "Etienne DURIS © ESIPE­MLV Université Paris­Est Marne­la­Vallée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 137,
    "type": "paragraph",
    "text": "137"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 137,
    "type": "paragraph",
    "text": "Comparaison externe"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 137,
    "type": "paragraph",
    "text": "➢ L'interface java.util.Comparator permet de spécifier un ordre"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 137,
    "type": "paragraph",
    "text": "externe"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 137,
    "type": "paragraph",
    "text": "➢ Un ordre externe est un ordre valable juste à un moment donné"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 137,
    "type": "paragraph",
    "text": "(rien de naturel et d'évident)"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 137,
    "type": "paragraph",
    "text": "➢ La valeur de retour de compare suit les mêmes règles que"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 137,
    "type": "paragraph",
    "text": "compareTo"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 137,
    "type": "paragraph",
    "text": "➢ Par exemple, pour notre classe Person,"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 137,
    "type": "paragraph",
    "text": "➢ L'ordre de la date de naissance"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 137,
    "type": "paragraph",
    "text": "➢ L'ordre des prénoms, ou tout autre ordre « moins naturel »..."
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 137,
    "type": "code_line",
    "text": "public interface Comparator<T> { int compare(T o1, T o2); }"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 138,
    "type": "paragraph",
    "text": "Etienne DURIS © ESIPE­MLV Université Paris­Est Marne­la­Vallée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 138,
    "type": "paragraph",
    "text": "138"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 138,
    "type": "paragraph",
    "text": "Peut se décrire par une classe anonyme"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 138,
    "type": "code_line",
    "text": "// ... public static void main(String args) { Person array = { … }; Arrays. sort (array); System. out .println(Arrays. toString (array)); Arrays. sort (array, new Comparator<Person>() { @Override public int compare(Person o1, Person o2) { return o1. year - o2. year ; } }) ; System. out .println(Arrays. toString (array)); } }"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 138,
    "type": "paragraph",
    "text": "➢ Si on a besoin de cette classe qu'à un seul endroit..."
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 138,
    "type": "section",
    "text": "Affiche :"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 138,
    "type": "table",
    "text": "[(Dudu Titi 1950), (Paupau Seb 2010), (Toto Abdel 1990), (Toto Titi 1900), (Toto Titi 1990), (Toto Zora 1990)]\n[(Toto Titi 1900), (Dudu Titi 1950), (Toto Abdel 1990), (Toto Titi 1990), (Toto Zora 1990), (Paupau Seb 2010)]"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 138,
    "type": "paragraph",
    "text": "Ordre naturel"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 138,
    "type": "paragraph",
    "text": "Ordre de"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 138,
    "type": "paragraph",
    "text": "l'age de naissance"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 139,
    "type": "paragraph",
    "text": "Etienne DURIS © ESIPE­MLV Université Paris­Est Marne­la­Vallée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 139,
    "type": "paragraph",
    "text": "139"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 139,
    "type": "paragraph",
    "text": "Comparator inverse"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 139,
    "type": "paragraph",
    "text": "➢ Il existe deux méthodes static dans la classe"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 139,
    "type": "section",
    "text": "java.util.Collections qui renvoie un comparator correspondant à :"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 139,
    "type": "paragraph",
    "text": "➢ L'inverse de l'ordre naturel"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 139,
    "type": "paragraph",
    "text": "➢ L'inverse d'un ordre externe sur T"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 139,
    "type": "code_block",
    "text": "<T> Comparator<T> Collections.reverseOrder();\n<T> Comparator<T> Collections.reverseOrder(Comparator<T> c);"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 140,
    "type": "paragraph",
    "text": "Etienne DURIS © ESIPE­MLV Université Paris­Est Marne­la­Vallée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 140,
    "type": "paragraph",
    "text": "140"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 140,
    "type": "paragraph",
    "text": "L'API des collections"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 140,
    "type": "diagram",
    "text": "➢ 2 paquetages : java.util, java.util.concurrent\n➢ 2 hiérarchies d'interfaces : Collection, Map\nCollection"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 140,
    "type": "paragraph",
    "text": "List Queue Set"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 140,
    "type": "paragraph",
    "text": "SortedSet BlockingQueue"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 140,
    "type": "diagram",
    "text": "ConcurrentMap\nMap\nSortedMap\nNavigableMap\nDeque"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 140,
    "type": "paragraph",
    "text": "NavigableSet ConcurrentNavigableMap"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 141,
    "type": "paragraph",
    "text": "Etienne DURIS © ESIPE­MLV Université Paris­Est Marne­la­Vallée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 141,
    "type": "paragraph",
    "text": "141"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 141,
    "type": "diagram_element",
    "text": "Design"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 141,
    "type": "paragraph",
    "text": "➢ Séparation Interface/implantation"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 141,
    "type": "paragraph",
    "text": "➢ Plusieurs implantations pour une interface"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 141,
    "type": "paragraph",
    "text": "permet d'obtenir en fonction de l'algorithme que l'on veut écrire la meilleure complexité"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 141,
    "type": "paragraph",
    "text": "➢ Deux classes contenant des algorithmes communs (méthodes"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 141,
    "type": "paragraph",
    "text": "statiques dans java.util.Arrays et java.util.Collections)"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 142,
    "type": "paragraph",
    "text": "Etienne DURIS © ESIPE­MLV Université Paris­Est Marne­la­Vallée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 142,
    "type": "paragraph",
    "text": "142"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 142,
    "type": "paragraph",
    "text": "Interfaces des collections"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 142,
    "type": "section",
    "text": "➢ Définition abstraite des collections :"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 142,
    "type": "paragraph",
    "text": "➢ Collection ensemble de données"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 142,
    "type": "paragraph",
    "text": "➢ Set ensemble de données sans doublon"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 142,
    "type": "paragraph",
    "text": "➢ SortedSet ensemble ordonné et sans doublon"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 142,
    "type": "paragraph",
    "text": "➢ NavigableSet ensemble ordonné, sans doublon avec précédent suivant"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 142,
    "type": "paragraph",
    "text": "➢ List liste indexée ou séquentielle"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 142,
    "type": "paragraph",
    "text": "➢ Queue file (FIFO) de données"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 142,
    "type": "paragraph",
    "text": "➢ BlockingQueue file bloquante de données"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 142,
    "type": "paragraph",
    "text": "➢ Deque double­ended queue"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 143,
    "type": "paragraph",
    "text": "Etienne DURIS © ESIPE­MLV Université Paris­Est Marne­la­Vallée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 143,
    "type": "paragraph",
    "text": "143"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 143,
    "type": "paragraph",
    "text": "Interfaces des maps"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 143,
    "type": "section",
    "text": "➢ Permet d'associer un objet (la clé) à un autre :"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 143,
    "type": "paragraph",
    "text": "➢ Map association sans relation d'ordre"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 143,
    "type": "paragraph",
    "text": "➢ SortedMap association avec clés triées"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 143,
    "type": "paragraph",
    "text": "➢ NavigableMap association avec clés triées avec suivant/précédent"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 143,
    "type": "paragraph",
    "text": "➢ ConcurrentMap association à accès concurrent"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 144,
    "type": "paragraph",
    "text": "Etienne DURIS © ESIPE­MLV Université Paris­Est Marne­la­Vallée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 144,
    "type": "paragraph",
    "text": "144"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 144,
    "type": "diagram_element",
    "text": "Iterator"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 144,
    "type": "paragraph",
    "text": "➢ Pour parcourir une collection, on utilise un objet permettant de"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 144,
    "type": "paragraph",
    "text": "passer en revue les différents éléments de la collection"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 144,
    "type": "section",
    "text": "➢ java.util.Iterator<E> définie :"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 144,
    "type": "paragraph",
    "text": "➢ boolean hasNext() qui renvoie vrai s'il y a un suivant"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 144,
    "type": "paragraph",
    "text": "➢ E next() qui renvoie l'élément courant et décale sur l'élément"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 144,
    "type": "paragraph",
    "text": "suivant"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 144,
    "type": "paragraph",
    "text": "➢ void remove() qui retire un élément précédemment envoyé par"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 144,
    "type": "paragraph",
    "text": "next() – opération « optionnelle »"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 145,
    "type": "paragraph",
    "text": "Etienne DURIS © ESIPE­MLV Université Paris­Est Marne­la­Vallée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 145,
    "type": "paragraph",
    "text": "145"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 145,
    "type": "paragraph",
    "text": "next() et NoSuchElementException"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 145,
    "type": "paragraph",
    "text": "➢ L'opération next() est sécurisée et lève une exception runtime"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 145,
    "type": "paragraph",
    "text": "NoSuchElementException dans le cas où on dépasse la fin de la collection (c­a­d si hasNext() renvoie false)"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 145,
    "type": "code_line",
    "text": "public static void main(String args) { Collection<Integer> c=new ArrayList<Integer>(); c.add(3); Iterator<Integer> it=c.iterator(); it.next(); it.next(); // NoSuchElementException }"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 146,
    "type": "paragraph",
    "text": "Etienne DURIS © ESIPE­MLV Université Paris­Est Marne­la­Vallée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 146,
    "type": "paragraph",
    "text": "146"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 146,
    "type": "paragraph",
    "text": "Exemple d'iterateur"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 146,
    "type": "paragraph",
    "text": "➢ Conceptuellement un iterateur s'utilise comme un pointeur que"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 146,
    "type": "paragraph",
    "text": "l'on décale sur la collection"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 146,
    "type": "code_line",
    "text": "public static void main(String args) { Collection<Integer> c=new ArrayList<Integer>(); c.add(3); c.add(2); c.add(4); Iterator<Integer> it=c.iterator(); for (;it.hasNext();) { System.out.println(it.next()*2); } // affiche 6, 4, 8 }"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 147,
    "type": "paragraph",
    "text": "Etienne DURIS © ESIPE­MLV Université Paris­Est Marne­la­Vallée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 147,
    "type": "paragraph",
    "text": "147"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 147,
    "type": "paragraph",
    "text": "Intérêt des itérateurs"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 147,
    "type": "section",
    "text": "➢ Pour le parcours d'une collection:"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 147,
    "type": "paragraph",
    "text": "➢ Pas toujours possible d'effectuer un parcours avec un index (Set,"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 147,
    "type": "paragraph",
    "text": "Queue, Deque)"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 147,
    "type": "paragraph",
    "text": "➢ Problème de complexité (List séquential)"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 147,
    "type": "paragraph",
    "text": "➢ Les iterateurs offrent un parcours garanti en O(n)"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 148,
    "type": "paragraph",
    "text": "Etienne DURIS © ESIPE­MLV Université Paris­Est Marne­la­Vallée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 148,
    "type": "paragraph",
    "text": "148"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 148,
    "type": "paragraph",
    "text": "Implantation des collections"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 148,
    "type": "paragraph",
    "text": "➢ Chaque collection possède une classe abstraite"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 148,
    "type": "diagram_element",
    "text": "Collection"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 148,
    "type": "paragraph",
    "text": "List Queue Set"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 148,
    "type": "paragraph",
    "text": "AbstractSet AbstractList AbstractQueue"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 148,
    "type": "diagram",
    "text": "AbstractCollection\nAbstractSequentialList\nDeque"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 149,
    "type": "paragraph",
    "text": "Etienne DURIS © ESIPE­MLV Université Paris­Est Marne­la­Vallée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 149,
    "type": "paragraph",
    "text": "149"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 149,
    "type": "diagram_element",
    "text": "Set"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 149,
    "type": "paragraph",
    "text": "➢ Hiérarchie des ensembles Collection"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 149,
    "type": "diagram",
    "text": "Set\nSortedSet\nHashSet\nLinkedHashSet"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 149,
    "type": "paragraph",
    "text": "TreeSet EnumSet CopyOnWriteArraySet"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 149,
    "type": "diagram",
    "text": "AbstractSet\nAbstractCollection\nNavigableSet"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 150,
    "type": "paragraph",
    "text": "Etienne DURIS © ESIPE­MLV Université Paris­Est Marne­la­Vallée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 150,
    "type": "paragraph",
    "text": "150"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 150,
    "type": "paragraph",
    "text": "Queue & Deque"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 150,
    "type": "diagram",
    "text": "Collection\nQueue\nBlockingQueue\nAbstractQueue\nAbstractCollection"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 150,
    "type": "paragraph",
    "text": "LinkedList PriorityQueue"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 150,
    "type": "diagram",
    "text": "ConcurrentLinkedQueue\nDeque\nBlockingDeque\nArrayDeque"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 151,
    "type": "paragraph",
    "text": "Etienne DURIS © ESIPE­MLV Université Paris­Est Marne­la­Vallée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 151,
    "type": "paragraph",
    "text": "151"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 151,
    "type": "diagram_element",
    "text": "List"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 151,
    "type": "paragraph",
    "text": "➢ Gére les listes séquentielles"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 151,
    "type": "paragraph",
    "text": "et indexées Collection"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 151,
    "type": "diagram_element",
    "text": "List"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 151,
    "type": "paragraph",
    "text": "RandomAccess AbstractList"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 151,
    "type": "diagram",
    "text": "AbstractCollection\nAbstractSequentialList"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 151,
    "type": "paragraph",
    "text": "LinkedList ArrayList Vector"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 151,
    "type": "diagram",
    "text": "Stack\nCopyOnWriteArrayList"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 152,
    "type": "paragraph",
    "text": "Etienne DURIS © ESIPE­MLV Université Paris­Est Marne­la­Vallée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 152,
    "type": "paragraph",
    "text": "152"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 152,
    "type": "diagram_element",
    "text": "Map"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 152,
    "type": "paragraph",
    "text": "➢ Association entre une clé et une valeur"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 152,
    "type": "diagram",
    "text": "Map\nAbstractMap\nHashMap\nLinkedHashMap\nHashtable\nConcurrentHashMap\nTreeMap"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 152,
    "type": "paragraph",
    "text": "WeakHashMap IdentityHashMap"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 152,
    "type": "diagram",
    "text": "ConcurrentMap\nEnumMap\nConcurrentSkipListMap\nSortedMap\nConcurrentNavigableMap\nNavigableMap"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 153,
    "type": "paragraph",
    "text": "Etienne DURIS © ESIPE­MLV Université Paris­Est Marne­la­Vallée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 153,
    "type": "paragraph",
    "text": "153"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 153,
    "type": "paragraph",
    "text": "Quelques mots sur java.io"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 153,
    "type": "paragraph",
    "text": "➢ 2 versions des entrées/sorties"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 153,
    "type": "paragraph",
    "text": "➢ InputStream / OutputStream manipulent des octets"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 153,
    "type": "paragraph",
    "text": "(byte en Java) donc dépendant de la plateforme"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 153,
    "type": "paragraph",
    "text": "➢ Reader / Writer manipulent des caractères"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 153,
    "type": "paragraph",
    "text": "(char en Java) indépendant de la plateforme mais qui nécessitent d'indiquer un codage des caractères"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 153,
    "type": "paragraph",
    "text": "➢ On utilise l'une ou l'autre des versions en fonction de ce que l'on"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 153,
    "type": "paragraph",
    "text": "veut faire"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 153,
    "type": "paragraph",
    "text": "➢ Lire un fichier de propriété ( Reader )"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 153,
    "type": "paragraph",
    "text": "➢ Ecrire un fichier binaire ( OutputStream )"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 154,
    "type": "paragraph",
    "text": "Etienne DURIS © ESIPE­MLV Université Paris­Est Marne­la­Vallée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 154,
    "type": "paragraph",
    "text": "154"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 154,
    "type": "paragraph",
    "text": "Entrées/sorties par byte"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 154,
    "type": "paragraph",
    "text": "InputStream OutputStream"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 154,
    "type": "diagram",
    "text": "FileInputStream\nObjectInputStream\nFilterInputStream\nBufferedInputStream\nPushBackInputStream\nFileOutputStream\nObjectOutputStream\nFilterOutputStream\nBufferedOutputStream\nPrintOutputStream"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 155,
    "type": "paragraph",
    "text": "Etienne DURIS © ESIPE­MLV Université Paris­Est Marne­la­Vallée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 155,
    "type": "paragraph",
    "text": "155"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 155,
    "type": "diagram_element",
    "text": "InputStream"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 155,
    "type": "paragraph",
    "text": "➢ Flux de byte en entrée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 155,
    "type": "paragraph",
    "text": "➢ Lit un byte et renvoie ce byte ou ­1 si c'est la fin du flux"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 155,
    "type": "paragraph",
    "text": "➢ abstract int read ()"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 155,
    "type": "paragraph",
    "text": "➢ Lit un tableau de byte (plus efficace)"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 155,
    "type": "paragraph",
    "text": "➢ int read (byte b)"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 155,
    "type": "paragraph",
    "text": "➢ int read (byte b, int off, int len)"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 155,
    "type": "paragraph",
    "text": "➢ Saute un nombre de bytes"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 155,
    "type": "paragraph",
    "text": "➢ long skip (long n)"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 155,
    "type": "paragraph",
    "text": "➢ Ferme le flux"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 155,
    "type": "paragraph",
    "text": "➢ void close ()"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 156,
    "type": "paragraph",
    "text": "Etienne DURIS © ESIPE­MLV Université Paris­Est Marne­la­Vallée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 156,
    "type": "paragraph",
    "text": "156"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 156,
    "type": "paragraph",
    "text": "InputStream et appel bloquant"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 156,
    "type": "paragraph",
    "text": "➢ Les méthodes read () sur un flux sont bloquantes s'il n'y a pas"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 156,
    "type": "paragraph",
    "text": "au moins un byte à lire"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 156,
    "type": "paragraph",
    "text": "➢ Il existe une méthode available () dans InputStream qui est"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 156,
    "type": "paragraph",
    "text": "sensée renvoyer le nombre de byte lisible sans que la lecture sur le flux soit bloquée mais mauvais le support au niveau des OS (à ne pas utiliser)"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 157,
    "type": "paragraph",
    "text": "Etienne DURIS © ESIPE­MLV Université Paris­Est Marne­la­Vallée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 157,
    "type": "paragraph",
    "text": "157"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 157,
    "type": "paragraph",
    "text": "InputStream et read d'un buffer"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 157,
    "type": "paragraph",
    "text": "➢ Attention, la lecture est une demande pour remplir le buffer, le"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 157,
    "type": "paragraph",
    "text": "système essaye de remplir le buffer au maximum mais peut ne pas le remplir complètement"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 157,
    "type": "paragraph",
    "text": "➢ Lecture dans un tableau de bytes"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 157,
    "type": "paragraph",
    "text": "➢ int read (byte b)"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 157,
    "type": "paragraph",
    "text": "renvoie le nombre de bytes lus"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 157,
    "type": "paragraph",
    "text": "➢ int read (byte b, int off, int len)"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 157,
    "type": "paragraph",
    "text": "renvoie le nombre de bytes lus"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 158,
    "type": "paragraph",
    "text": "Etienne DURIS © ESIPE­MLV Université Paris­Est Marne­la­Vallée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 158,
    "type": "paragraph",
    "text": "158"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 158,
    "type": "paragraph",
    "text": "InputStream et efficacité"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 158,
    "type": "paragraph",
    "text": "➢ Contrairement au C (stdio) par défaut en Java, les entrées"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 158,
    "type": "paragraph",
    "text": "sorties ne sont pas bufferisés"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 158,
    "type": "paragraph",
    "text": "➢ Risque de gros problème de performance si on lit les données"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 158,
    "type": "paragraph",
    "text": "octets par octest"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 158,
    "type": "section",
    "text": "➢ Solution :"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 158,
    "type": "paragraph",
    "text": "➢ Lire utilisant un buffer"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 158,
    "type": "paragraph",
    "text": "➢ Uitliser un BufferedInputStream qui utilise un buffer intermédiaire"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 159,
    "type": "paragraph",
    "text": "Etienne DURIS © ESIPE­MLV Université Paris­Est Marne­la­Vallée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 159,
    "type": "paragraph",
    "text": "159"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 159,
    "type": "paragraph",
    "text": "InputStream et IOException"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 159,
    "type": "paragraph",
    "text": "➢ Toutes les méthodes de l'input stream peuvent lever une"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 159,
    "type": "paragraph",
    "text": "IOException pour indiquer que"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 159,
    "type": "paragraph",
    "text": "➢ Il y a eu une erreur d'entrée/sortie"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 159,
    "type": "paragraph",
    "text": "➢ Que le stream est fermé après un appel à close ()"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 159,
    "type": "paragraph",
    "text": "➢ Que le thread courant a été interrompu en envoyant une"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 159,
    "type": "paragraph",
    "text": "InterruptedIOException (cf cours sur la concurrence)"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 159,
    "type": "paragraph",
    "text": "➢ Il faut penser un faire un close () sur le stream dans ce cas"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 160,
    "type": "paragraph",
    "text": "Etienne DURIS © ESIPE­MLV Université Paris­Est Marne­la­Vallée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 160,
    "type": "paragraph",
    "text": "160"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 160,
    "type": "diagram",
    "text": "OutputStream\n➢ Flux de byte en sortie : OutputStream"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 160,
    "type": "paragraph",
    "text": "➢ Ecrit un byte, en fait un int pour qu'il marche avec le read"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 160,
    "type": "paragraph",
    "text": "➢ abstract void write(int b)"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 160,
    "type": "paragraph",
    "text": "➢ Ecrit un tableau de byte (plus efficace)"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 160,
    "type": "paragraph",
    "text": "➢ void write (byte b)"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 160,
    "type": "paragraph",
    "text": "➢ void write (byte b, int off, int len)"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 160,
    "type": "paragraph",
    "text": "➢ Demande d'écrire ce qu'il y a dans le buffer"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 160,
    "type": "paragraph",
    "text": "➢ void flush ()"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 160,
    "type": "paragraph",
    "text": "➢ Ferme le flux"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 160,
    "type": "paragraph",
    "text": "➢ void close ()"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 161,
    "type": "paragraph",
    "text": "Etienne DURIS © ESIPE­MLV Université Paris­Est Marne­la­Vallée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 161,
    "type": "paragraph",
    "text": "161"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 161,
    "type": "paragraph",
    "text": "Copie de flux"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 161,
    "type": "paragraph",
    "text": "➢ Byte par byte (mal)"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 161,
    "type": "paragraph",
    "text": "➢ Par buffer de bytes"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 161,
    "type": "code_block",
    "text": "public static void copy(Inputstream in,OutputStream out) throws IOException {\nint b; while((b=in.read())!=-1) out.write(b); }\npublic static void copy(Inputstream in,OutputStream out) throws IOException {\nbyte buffer=new byte[8192]; int size; while((size=in.read(buffer))!=-1) out.write(buffer,0, size ); }"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 162,
    "type": "paragraph",
    "text": "Etienne DURIS © ESIPE­MLV Université Paris­Est Marne­la­Vallée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 162,
    "type": "paragraph",
    "text": "162"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 162,
    "type": "paragraph",
    "text": "Entrées/sorties par char"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 162,
    "type": "paragraph",
    "text": "Reader Writer"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 162,
    "type": "diagram",
    "text": "FileReader\nInputStreamReader\nFilterReader\nBufferedReader\nPushBackReader\nFileWriter\nOutputStreamWriter\nFilterWriter\nBufferedWriter\nPrintWriter"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 163,
    "type": "paragraph",
    "text": "Etienne DURIS © ESIPE­MLV Université Paris­Est Marne­la­Vallée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 163,
    "type": "paragraph",
    "text": "163"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 163,
    "type": "diagram_element",
    "text": "Reader"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 163,
    "type": "paragraph",
    "text": "➢ Flux de char en entrée (méthode bloquante)"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 163,
    "type": "paragraph",
    "text": "➢ Lit un char et renvoie celui­ci ou ­1 si c'est la fin du flux"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 163,
    "type": "paragraph",
    "text": "➢ abstract int read ()"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 163,
    "type": "paragraph",
    "text": "➢ Lit un tableau de char (plus efficace)"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 163,
    "type": "paragraph",
    "text": "➢ int read (char b)"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 163,
    "type": "paragraph",
    "text": "➢ int read (char b, int off, int len)"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 163,
    "type": "paragraph",
    "text": "➢ Saute un nombre de caractères"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 163,
    "type": "paragraph",
    "text": "➢ long skip (long n)"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 163,
    "type": "paragraph",
    "text": "➢ Ferme le flux"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 163,
    "type": "paragraph",
    "text": "➢ void close ()"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 164,
    "type": "paragraph",
    "text": "Etienne DURIS © ESIPE­MLV Université Paris­Est Marne­la­Vallée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 164,
    "type": "paragraph",
    "text": "164"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 164,
    "type": "diagram_element",
    "text": "Writer"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 164,
    "type": "paragraph",
    "text": "➢ Flux de caractère en sortie"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 164,
    "type": "paragraph",
    "text": "➢ Ecrit un caractère, un int pour qu'il marche avec le read"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 164,
    "type": "paragraph",
    "text": "➢ abstract void write(int c)"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 164,
    "type": "paragraph",
    "text": "➢ Ecrit un tableau de caractère (plus efficace)"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 164,
    "type": "paragraph",
    "text": "➢ void write (char b)"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 164,
    "type": "paragraph",
    "text": "➢ void write (char b, int off, int len)"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 164,
    "type": "paragraph",
    "text": "➢ Demande d'écrire ce qu'il y a dans le buffer"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 164,
    "type": "paragraph",
    "text": "➢ void flush ()"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 164,
    "type": "paragraph",
    "text": "➢ Ferme le flux"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 164,
    "type": "paragraph",
    "text": "➢ void close ()"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 165,
    "type": "paragraph",
    "text": "Etienne DURIS © ESIPE­MLV Université Paris­Est Marne­la­Vallée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 165,
    "type": "paragraph",
    "text": "165"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 165,
    "type": "paragraph",
    "text": "Writer et chaine de caractères"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 165,
    "type": "paragraph",
    "text": "➢ Un Writer possède des méthodes spéciales pour l'écriture de"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 165,
    "type": "paragraph",
    "text": "chaîne de caractères"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 165,
    "type": "paragraph",
    "text": "➢ Ecrire une String,"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 165,
    "type": "paragraph",
    "text": "➢ void write (String s)"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 165,
    "type": "paragraph",
    "text": "➢ Void write (String str, int off, int len)"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 165,
    "type": "paragraph",
    "text": "➢ Un writer est un Appendable donc"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 165,
    "type": "paragraph",
    "text": "➢ Ecrire un CharSequence"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 165,
    "type": "paragraph",
    "text": "➢ Writer append (CharSequence csq)"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 165,
    "type": "paragraph",
    "text": "➢ Writer append (CharSequence csq, int start, int end)"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 166,
    "type": "paragraph",
    "text": "Etienne DURIS © ESIPE­MLV Université Paris­Est Marne­la­Vallée"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 166,
    "type": "paragraph",
    "text": "166"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 166,
    "type": "paragraph",
    "text": "Copie de flux"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 166,
    "type": "paragraph",
    "text": "➢ Caractère par caractère (mal)"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 166,
    "type": "paragraph",
    "text": "➢ Par buffer de caractères"
  },
  {
    "source": "JavaLesBases.pdf",
    "page": 166,
    "type": "code_block",
    "text": "public static void copy(Reader in,Writer out) throws IOException {\nint c; while((c=in.read())!=-1) out.write(c); }\npublic static void copy(Reader in,Writer out) throws IOException {\nchar buffer=new char[8192]; int size; while((size=in.read(buffer))!=-1) out.write(buffer,0, size ); }"
  }
]